<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI Generated App</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js"></script>
    <!-- html2canvas-pro handles modern CSS color formats like OKLCH natively -->
    <link rel="stylesheet" href="https://esm.sh/use-vibes@latest/dist/components/ImgGen.css" />
    <style>
      /* HYPERPOP-INSPIRED DESIGN SYSTEM */
      :root {
        /* Typography */
        --font-heading: "Arial Black", "Helvetica Bold", system-ui, sans-serif;
        --font-base: "Arial", "Helvetica", system-ui, sans-serif;
        --font-mono: "Courier New", "IBM Plex Mono", monospace;
        
        /* REFINED COLOR PALETTE - Sophisticated & Harmonious */
        
        /* BASE PALETTE - Core Design Colors */
        --ultra-violet: rgba(86, 71, 135, 1);      /* Deep purple - Primary brand */
        --moonstone: rgba(109, 177, 191, 1);       /* Cool blue-green - Secondary */
        --lavender-blush: rgba(255, 234, 236, 1);  /* Soft pink - Light accent */
        --salmon-pink: rgba(243, 154, 157, 1);     /* Warm pink - Vibrant accent */
        --oxford-blue: rgba(16, 25, 53, 1);        /* Deep navy - Dark foundation */
        
        /* SEMANTIC COLORS - Functional application */
        --color-primary: var(--ultra-violet);      /* Primary actions & brand */
        --color-secondary: var(--moonstone);       /* Secondary actions */
        --color-accent: var(--salmon-pink);        /* Highlights & selections */
        --color-warning: rgba(255, 193, 7, 1);     /* Warning yellow */
        --color-danger: rgba(220, 53, 69, 1);      /* Error red */
        --color-success: rgba(40, 167, 69, 1);     /* Success green */
        
        /* BACKGROUNDS - Layered surfaces */
        --color-bg-primary: #ffffff;               /* Pure white for main content */
        --color-bg-secondary: var(--lavender-blush); /* Soft pink for secondary surfaces */
        --color-bg-tertiary: rgba(249, 250, 251, 1); /* Light gray for subtle areas */
        --color-bg-dark: var(--oxford-blue);       /* Dark navy for contrast */
        --color-bg-gradient: linear-gradient(135deg, var(--lavender-blush) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(109, 177, 191, 0.3) 100%);
        
        /* TEXT COLORS - Optimal readability */
        --color-text-primary: var(--oxford-blue);  /* Dark navy for main text */
        --color-text-inverse: #ffffff;             /* White on dark backgrounds */
        --color-text-muted: rgba(86, 71, 135, 0.6); /* Muted ultra-violet */
        --color-text-accent: var(--ultra-violet);  /* Ultra-violet for emphasis */
        
        /* BORDERS & SHADOWS - Refined structure */
        --color-border: var(--oxford-blue);        /* Navy borders for definition */
        --color-border-accent: var(--ultra-violet); /* Purple borders for emphasis */
        --border-width: 3px;                       /* Bold but refined borders */
        --border-radius: 12px;                     /* Soft rounded corners */
        
        /* SHADOWS - Sophisticated depth */
        --shadow-offset-x: 6px;
        --shadow-offset-y: 6px;
        --shadow-color: var(--ultra-violet);       /* Ultra-violet primary shadows */
        --shadow-color-alt: var(--moonstone);      /* Moonstone secondary shadows */
        --shadow-main: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--shadow-color);
        --shadow-alt: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--shadow-color-alt);
        --shadow-hover: 3px 3px 0px var(--shadow-color);
        --shadow-active: 0px 0px 0px var(--shadow-color);
        
        /* SPACING - Consistent scale */
        --space-xs: 4px;
        --space-sm: 8px;
        --space-md: 16px;
        --space-lg: 24px;
        --space-xl: 32px;
        --space-xxl: 48px;
        
        /* Z-INDEX - Layering system */
        --z-tooltip: 1000;
        --z-modal: 2000;
        --z-popover: 3000;
      }
      
      body {
        margin: 0;
        padding: 0;
        font-family: var(--font-base);
        font-weight: 400;
        background: var(--color-bg-gradient);
        color: var(--color-text-primary);
        line-height: 1.4;
      }
      
      #container {
        width: 100%;
        min-height: 100vh;
        background: var(--color-bg-gradient);
        position: relative;
      }
      
      /* Sophisticated background pattern */
      #container::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          radial-gradient(circle at 20% 20%, var(--ultra-violet) 0%, transparent 20%),
          radial-gradient(circle at 80% 80%, var(--moonstone) 0%, transparent 20%),
          radial-gradient(circle at 40% 60%, var(--salmon-pink) 0%, transparent 20%);
        background-size: 200px 200px, 150px 150px, 180px 180px;
        opacity: 0.05;
        pointer-events: none;
        z-index: -1;
      }
      
      /* =================
         NEOBRUTALISM COMPONENTS 
         ================= */
      
      /* Base Button Component */
      .neo-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
        border-radius: var(--border-radius);
        font-family: var(--font-heading);
        font-weight: 900;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.15s ease-out;
        gap: var(--space-sm);
        cursor: pointer;
        border: var(--border-width) solid var(--color-border);
        box-shadow: var(--shadow-main);
        position: relative;
        user-select: none;
        text-decoration: none;
        min-height: 48px;
        padding: 0 var(--space-lg);
      }
      
      .neo-btn:hover:not(:disabled) {
        transform: translate(calc(var(--shadow-offset-x) / 2), calc(var(--shadow-offset-y) / 2));
        box-shadow: var(--shadow-hover);
      }
      
      .neo-btn:active:not(:disabled) {
        transform: translate(var(--shadow-offset-x), var(--shadow-offset-y));
        box-shadow: var(--shadow-active);
      }
      
      .neo-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      
      /* Button Variants - Refined Color Harmony */
      .neo-btn-primary { 
        background-color: var(--color-primary); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-main);
      }
      .neo-btn-secondary { 
        background-color: var(--color-secondary); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-alt);
      }
      .neo-btn-accent { 
        background-color: var(--color-accent); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-main);
      }
      .neo-btn-warning { 
        background-color: var(--color-warning); 
        color: var(--oxford-blue); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet);
      }
      .neo-btn-danger { 
        background-color: var(--color-danger); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--moonstone);
      }
      .neo-btn-success { 
        background-color: var(--color-success); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--salmon-pink);
      }
      .neo-btn-neutral { 
        background-color: var(--color-bg-primary); 
        color: var(--color-text-primary); 
        box-shadow: var(--shadow-main);
      }
      
      /* Button Sizes */
      .neo-btn-sm { min-height: 36px; padding: 0 var(--space-md); font-size: 14px; }
      .neo-btn-lg { min-height: 56px; padding: 0 var(--space-xl); font-size: 18px; }
      .neo-btn-icon { width: 48px; height: 48px; padding: 0; }
      
      /* Card Component */
      .neo-card {
        background-color: var(--color-bg-primary);
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-main);
        padding: var(--space-xl);
        position: relative;
      }
      
      .neo-card-header {
        margin-bottom: var(--space-lg);
      }
      
      .neo-card-title {
        font-family: var(--font-heading);
        font-size: 24px;
        font-weight: 900;
        margin: 0 0 var(--space-sm) 0;
        text-transform: uppercase;
        letter-spacing: 0.02em;
      }
      
      .neo-card-description {
        color: var(--color-text-muted);
        margin: 0;
        font-size: 16px;
        line-height: 1.5;
      }
      
      .neo-card-content {
        margin-bottom: var(--space-lg);
      }
      
      .neo-card-footer {
        display: flex;
        gap: var(--space-md);
        justify-content: flex-end;
        border-top: var(--border-width) solid var(--color-border);
        padding-top: var(--space-lg);
        margin-top: var(--space-lg);
      }
      
      /* Badge Component */
      .neo-badge {
        display: inline-flex;
        align-items: center;
        border-radius: var(--border-radius);
        border: 2px solid var(--color-border);
        padding: var(--space-xs) var(--space-sm);
        font-family: var(--font-heading);
        font-size: 12px;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      
      .neo-badge-primary { background-color: var(--ultra-violet); color: var(--color-text-inverse); }
      .neo-badge-secondary { background-color: var(--moonstone); color: var(--color-text-inverse); }
      .neo-badge-accent { background-color: var(--salmon-pink); color: var(--color-text-inverse); }
      .neo-badge-neutral { background-color: var(--color-bg-tertiary); color: var(--color-text-primary); }
      .neo-badge-pastel { background-color: var(--lavender-blush); color: var(--color-text-primary); }
      .neo-badge-dark { background-color: var(--oxford-blue); color: var(--color-text-inverse); }
      
      /* Input Component */
      .neo-input {
        width: 100%;
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        padding: var(--space-md);
        font-family: var(--font-base);
        font-size: 16px;
        background-color: var(--color-bg-primary);
        color: var(--color-text-primary);
        box-shadow: var(--shadow-main);
        transition: all 0.15s ease-out;
      }
      
      .neo-input:focus {
        outline: none;
        transform: translate(2px, 2px);
        box-shadow: var(--shadow-hover);
      }
      
      .neo-input::placeholder {
        color: var(--color-text-muted);
        font-style: italic;
      }
      
      /* Alert Component */
      .neo-alert {
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        padding: var(--space-lg);
        background-color: var(--color-bg-primary);
        box-shadow: var(--shadow-main);
        position: relative;
      }
      
      .neo-alert-title {
        font-family: var(--font-heading);
        font-size: 18px;
        font-weight: 900;
        margin: 0 0 var(--space-sm) 0;
        text-transform: uppercase;
      }
      
      .neo-alert-description {
        margin: 0;
        line-height: 1.5;
      }
      
      .neo-alert-warning {
        background-color: var(--color-warning);
        border-color: var(--ultra-violet);
        color: var(--oxford-blue);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet);
      }
      
      .neo-alert-danger {
        background-color: var(--color-danger);
        border-color: var(--moonstone);
        color: var(--color-text-inverse);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--moonstone);
      }
      
      .neo-alert-success {
        background-color: var(--color-success);
        border-color: var(--salmon-pink);
        color: var(--color-text-inverse);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--salmon-pink);
      }
      
      /* Typography */
      .neo-heading {
        font-family: var(--font-heading);
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        margin: 0 0 var(--space-md) 0;
      }
      
      .neo-heading-xl { font-size: 48px; line-height: 1.1; }
      .neo-heading-lg { font-size: 36px; line-height: 1.2; }
      .neo-heading-md { font-size: 24px; line-height: 1.3; }
      .neo-heading-sm { font-size: 18px; line-height: 1.4; }
      
      /* Layout Utilities */
      .neo-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--space-xl);
      }
      
      .neo-grid {
        display: grid;
        gap: var(--space-lg);
      }
      
      .neo-grid-cols-1 { grid-template-columns: 1fr; }
      .neo-grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
      .neo-grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
      
      .neo-flex {
        display: flex;
        gap: var(--space-md);
      }
      
      .neo-flex-col { flex-direction: column; }
      .neo-flex-wrap { flex-wrap: wrap; }
      .neo-justify-center { justify-content: center; }
      .neo-justify-between { justify-content: space-between; }
      .neo-items-center { align-items: center; }
      
      /* Spacing Utilities */
      .neo-mb-xs { margin-bottom: var(--space-xs); }
      .neo-mb-sm { margin-bottom: var(--space-sm); }
      .neo-mb-md { margin-bottom: var(--space-md); }
      .neo-mb-lg { margin-bottom: var(--space-lg); }
      .neo-mb-xl { margin-bottom: var(--space-xl); }
      
      .neo-mt-xs { margin-top: var(--space-xs); }
      .neo-mt-sm { margin-top: var(--space-sm); }
      .neo-mt-md { margin-top: var(--space-md); }
      .neo-mt-lg { margin-top: var(--space-lg); }
      .neo-mt-xl { margin-top: var(--space-xl); }
      
      /* Special Effects */
      .neo-shake:hover {
        animation: shake 0.5s ease-in-out;
      }
      
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-2px); }
        75% { transform: translateX(2px); }
      }
      
      /* Breathing animation for intention focus */
      @keyframes breathe {
        0%, 100% { 
          transform: scale(1);
          opacity: 0.9;
        }
        50% { 
          transform: scale(1.15);
          opacity: 1;
        }
      }
      
      /* Pulse ring animation */
      @keyframes pulse-ring {
        0% {
          transform: scale(1);
          opacity: 0.4;
        }
        100% {
          transform: scale(1.4);
          opacity: 0;
        }
      }
      
      /* Fade in animation */
      @keyframes fade-in {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      /* Count fade animation */
      @keyframes count-fade {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
    </style>
    <script>
      const activeRequests = new Set();
      let lastState = null;

      function updateStreamingState() {
        const currentState = activeRequests.size > 0;
        if (currentState !== lastState) {
          lastState = currentState;
          window.parent.postMessage({ type: 'streaming', state: currentState }, '*');
        }
      }

      const originalFetch = window.fetch;
      window.fetch = (...args) => {
        const reqInfo = args[0];
        activeRequests.add(reqInfo);
        updateStreamingState();

        return originalFetch(...args).then((res) => {
          if (!res.body) {
            activeRequests.delete(reqInfo);
            updateStreamingState();
            return res;
          }
          const reader = res.body.getReader();
          const stream = new ReadableStream({
            start(controller) {
              function pump() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    activeRequests.delete(reqInfo);
                    updateStreamingState();
                    controller.close();
                    return;
                  }
                  controller.enqueue(value);
                  pump();
                });
              }
              pump();
            },
          });
          return new Response(stream, { headers: res.headers });
        });
      };

      // Screenshot functionality
      function cropToMaxAspectRatio(canvas, maxAspectRatio) {
        const width = canvas.width;
        const height = canvas.height;
        const currentAspectRatio = height / width;

        // If already within the max aspect ratio, return original canvas
        if (currentAspectRatio <= maxAspectRatio) {
          return canvas;
        }

        // Calculate new dimensions - crop from the bottom
        const newHeight = width * maxAspectRatio;
        const cropY = 0; // Start from top

        // Create new canvas with cropped dimensions
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = width;
        croppedCanvas.height = newHeight;

        const ctx = croppedCanvas.getContext('2d');

        // Draw cropped portion of original canvas
        ctx.drawImage(
          canvas,
          0,
          cropY,
          width,
          newHeight, // Source rectangle (crop from original)
          0,
          0,
          width,
          newHeight // Destination rectangle (full new canvas)
        );

        return croppedCanvas;
      }

      function captureScreenshot() {
        // Check if html2canvas is loaded
        if (typeof html2canvas === 'undefined') {
          // Try to load html2canvas-pro dynamically
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js';
          script.onload = () => {
            captureScreenshotWithFallback();
          };
          script.onerror = (e) => {
            window.parent.postMessage(
              { type: 'screenshot-error', error: 'Failed to load html2canvas' },
              '*'
            );
          };
          document.head.appendChild(script);
          return;
        }

        captureScreenshotWithFallback();
      }

      function captureScreenshotWithFallback() {
        try {
          // Let html2canvas-pro do its job with modern CSS
          html2canvas(document.body, {
            allowTaint: true,
            useCORS: true,
            scale: 1,
            logging: false,
          })
            .then((canvas) => {
              // Crop to max 3:1 aspect ratio (3 times taller than wide)
              const croppedCanvas = cropToMaxAspectRatio(canvas, 3);
              const dataURI = croppedCanvas.toDataURL();
              window.parent.postMessage({ type: 'screenshot', data: dataURI }, '*');
            })
            .catch((err) => {
              window.parent.postMessage(
                {
                  type: 'screenshot-error',
                  error: 'Screenshot capture failed: ' + (err.message || 'Unknown error'),
                },
                '*'
              );
            });
        } catch (err) {
          window.parent.postMessage(
            {
              type: 'screenshot-error',
              error: 'Unexpected error during screenshot capture',
            },
            '*'
          );
        }
      }

      function pageIsLoaded() {
        window.parent.postMessage({ type: 'preview-ready' }, '*');
        setTimeout(captureScreenshot, 2000);
      }

      // For rapid updates (optional)
      let currentApp = null;
      function updateAppComponent(code) {
        try {
          // Evaluate new component code
          eval(code);

          // If we implement rapid updates, we'll need to re-render here
          if (currentApp && window.ReactDOM) {
            // Re-render with new component
          }

          return true;
        } catch (error) {
          console.error('Failed to update component:', error);
          return false;
        }
      }

      // Event listeners
      window.addEventListener('message', function (event) {
        if (event.data) {
          if (event.data.type === 'command') {
            if (event.data.command === 'capture-screenshot') {
              captureScreenshot();
            }
          } else if (event.data.type === 'callai-api-key' && event.data.key) {
            window.CALLAI_API_KEY = event.data.key;
          }
        }
      });

      window.addEventListener('DOMContentLoaded', function () {
        pageIsLoaded();
      });

      // Global error handlers to catch and log all errors
      window.onerror = function (message, source, lineno, colno, error) {
        const errorDetails = {
          type: 'error',
          message: message,
          source: source,
          lineno: lineno,
          colno: colno,
          stack: error?.stack || 'No stack trace available',
          timestamp: new Date().toISOString(),
        };
        console.error('Uncaught error:', errorDetails);
        // Send error to parent window
        window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
        return false; // Let the default error handler run
      };

      // Handle unhandled promise rejections
      window.addEventListener('unhandledrejection', function (event) {
        const errorDetails = {
          type: 'unhandledrejection',
          reason: event.reason?.toString() || 'Unknown reason',
          stack: event.reason?.stack || 'No stack trace available',
          timestamp: new Date().toISOString(),
        };
        // Send rejection to parent window
        window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
      });
    </script>
  </head>
  <body>
    <div id="container"></div>
    <script>
      window.CALLAI_API_KEY = 'sk-vibes-proxy-managed';
      window.SESSION_ID = 'fmejcgpq8ncqrglokd';
      window.CALLAI_CHAT_URL = 'https://vibes-diy-api.com';
      window.CALLAI_IMG_URL = 'https://vibes-diy-api.com';
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.1/es2022/react.mjs",
          "react-dom": "https://esm.sh/react-dom@19.1.1/es2022/react-dom.mjs",
          "react-dom/client": "https://esm.sh/react-dom@19.1.1/es2022/client.mjs",
          "use-fireproof": "https://esm.sh/use-fireproof@0.23.0",
          "call-ai": "https://esm.sh/call-ai",
          "use-vibes": "https://esm.sh/use-vibes",
          "three": "https://esm.sh/three"
        }
      }
    </script>

    <!-- Enhanced Babel and JSX error handling script -->
    <script>
      window.babelTransformError = null;

      // 1. Patch console.error to capture JSX parse errors that are only logged to console
      const originalConsoleError = console.error;
      console.error = function (...args) {
        const errorMsg = args.join(' ');

        // Look for specific JSX parse errors that might not trigger other handlers
        if (
          errorMsg.includes('parse-error.ts') ||
          (errorMsg.includes('SyntaxError') && errorMsg.includes('Unexpected token')) ||
          errorMsg.includes('JSX')
        ) {
          // Extract line and position information if available
          let lineInfo = '';
          const lineMatch =
            errorMsg.match(/(\d+):(\d+)/) || errorMsg.match(/line (\d+).+column (\d+)/);
          if (lineMatch) {
            lineInfo = ` at line ${lineMatch[1]}, column ${lineMatch[2]}`;
          }

          // Extract meaningful error message
          let message = 'JSX Syntax Error';
          if (errorMsg.includes('Unexpected token')) {
            const tokenMatch = errorMsg.match(/Unexpected token[,:]?\s*([^,\n\)]+)/);
            if (tokenMatch) {
              message = `JSX Syntax Error: Unexpected token ${tokenMatch[1].trim()}`;
            }
          } else if (errorMsg.includes('expected')) {
            const expectedMatch = errorMsg.match(/expected\s+([^,\n\)]+)/);
            if (expectedMatch) {
              message = `JSX Syntax Error: Expected ${expectedMatch[1].trim()}`;
            }
          }

          const errorDetails = {
            type: 'error',
            message: `${message}${lineInfo}`,
            source: 'jsx-parser',
            stack: errorMsg,
            timestamp: new Date().toISOString(),
            errorType: 'SyntaxError',
          };

          // Only send if we haven't already reported an error
          if (!window.babelTransformError) {
            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
          }
        }

        // Call original console.error
        originalConsoleError.apply(console, args);
      };

      // 2. Patch Babel transform for errors caught during transformation
      if (window.Babel && window.Babel.transform) {
        const originalTransform = window.Babel.transform;
        window.Babel.transform = function (code, options) {
          try {
            return originalTransform.call(this, code, options);
          } catch (err) {
            // Capture and format Babel error
            const errorDetails = {
              type: 'error',
              message: `Babel Syntax Error: ${err.message || 'Invalid syntax'}`,
              source: 'babel-transform',
              stack: err.stack || '',
              timestamp: new Date().toISOString(),
              errorType: 'SyntaxError',
            };
            // Report error to parent
            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
            throw err;
          }
        };
      }

      // 3. Enhanced unhandled error handler specifically for syntax errors
      window.addEventListener(
        'error',
        function (event) {
          // Skip if we already caught the error elsewhere
          if (window.babelTransformError) return;

          // Focus on syntax errors and parse errors
          if (
            event.error?.stack?.includes('parse-error.ts') ||
            event.message?.includes('SyntaxError') ||
            (event.message === 'Script error.' && !event.filename)
          ) {
            let message = event.message;
            if (message === 'Script error.') {
              message = 'JSX Syntax Error: Unable to parse JSX code';
            }

            const errorDetails = {
              type: 'error',
              message: message,
              source: event.filename || 'jsx-parser',
              lineno: event.lineno || 0,
              colno: event.colno || 0,
              stack: event.error?.stack || '',
              timestamp: new Date().toISOString(),
              errorType: 'SyntaxError',
            };

            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
          }
        },
        true
      );
    </script>

    <script type="text/babel" data-type="module">
      import ReactDOMClient from 'react-dom/client';

      // App runs normally without our interference, but the iframe loads our script to modify use-fireproof
      // prettier-ignore
      import React, { useState, useEffect, useRef } from "react"
import { callAI } from "call-ai"
import { useFireproof } from "use-fireproof"

// ===========================
// NEOBRUTALISM COMPONENTS
// ===========================

// Button Component
function NeoButton({ 
  children, 
  onClick, 
  variant = 'primary', 
  size = 'md', 
  disabled = false, 
  className = '', 
  ...props 
}) {
  const classes = `neo-btn neo-btn-${variant} neo-btn-${size} ${className}`.trim();
  
  return (
    <button 
      className={classes}
      onClick={onClick}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
}

// Card Component
function NeoCard({ children, className = '', ...props }) {
  return (
    <div className={`neo-card ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardHeader({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-header ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardTitle({ children, className = '', ...props }) {
  return (
    <h3 className={`neo-card-title ${className}`} {...props}>
      {children}
    </h3>
  );
}

function NeoCardDescription({ children, className = '', ...props }) {
  return (
    <p className={`neo-card-description ${className}`} {...props}>
      {children}
    </p>
  );
}

function NeoCardContent({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-content ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardFooter({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-footer ${className}`} {...props}>
      {children}
    </div>
  );
}

// Badge Component
function NeoBadge({ children, variant = 'neutral', className = '', ...props }) {
  const classes = `neo-badge neo-badge-${variant} ${className}`.trim();
  
  return (
    <span className={classes} {...props}>
      {children}
    </span>
  );
}

// Heading Component
function NeoHeading({ children, level = 'md', className = '', ...props }) {
  const classes = `neo-heading neo-heading-${level} ${className}`.trim();
  const Tag = level === 'xl' || level === 'lg' ? 'h1' : 
             level === 'md' ? 'h2' : 'h3';
  
  return (
    <Tag className={classes} {...props}>
      {children}
    </Tag>
  );
}

// Alert Component
function NeoAlert({ children, variant = 'default', title, className = '', ...props }) {
  const classes = `neo-alert ${variant !== 'default' ? `neo-alert-${variant}` : ''} ${className}`.trim();
  
  return (
    <div className={classes} {...props}>
      {title && <div className="neo-alert-title">{title}</div>}
      <div className="neo-alert-description">
        {children}
      </div>
    </div>
  );
}

// Container Component
function NeoContainer({ children, className = '', ...props }) {
  return (
    <div className={`neo-container ${className}`} {...props}>
      {children}
    </div>
  );
}

// Progress Component (adapted from neobrutalism library)
function NeoProgress({ value, className = '', ...props }) {
  return (
    <div
      className={`neo-progress ${className}`}
      style={{
        position: 'relative',
        height: '16px',
        width: '100%',
        overflow: 'hidden',
        borderRadius: 'var(--border-radius)',
        border: 'var(--border-width) solid var(--color-border)',
        backgroundColor: 'var(--color-bg-tertiary)'
      }}
      {...props}
    >
      <div
        className="neo-progress-indicator"
        style={{
          height: '100%',
          width: '100%',
          flex: 1,
          borderRight: value < 100 ? 'var(--border-width) solid var(--color-border)' : 'none',
          backgroundColor: 'var(--salmon-pink)',
          transition: 'all 0.3s ease',
          transform: `translateX(-${100 - (value || 0)}%)`
        }}
      />
    </div>
  );
}

// Intention Focus Component with breathing animation
function IntentionFocus({ countdown, onComplete }) {
  React.useEffect(() => {
    if (countdown <= 0) {
      onComplete();
    }
  }, [countdown, onComplete]);

  return (
    <div style={{
      width: '140px',
      height: '120px',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'relative'
    }}>
      {/* Breathing Circle Animation */}
      <div style={{
        width: '80px',
        height: '80px',
        borderRadius: '50%',
        background: countdown > 0 ? 'var(--moonstone)' : 'var(--salmon-pink)',
        border: 'var(--border-width) solid var(--color-border)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        animation: 'breathe 2s ease-in-out infinite',
        boxShadow: 'var(--shadow-main)',
        position: 'relative',
        transition: 'background 0.3s ease'
      }}>
        {/* Pulse ring effect */}
        <div style={{
          position: 'absolute',
          top: '-8px',
          left: '-8px',
          right: '-8px',
          bottom: '-8px',
          borderRadius: '50%',
          border: '3px solid var(--salmon-pink)',
          animation: 'pulse-ring 1.5s ease-out infinite',
          opacity: 0.4
        }} />
        
        <div style={{
          fontSize: countdown > 0 ? '32px' : '24px',
          color: 'var(--color-text-inverse)',
          fontFamily: 'var(--font-heading)',
          fontWeight: '900',
          animation: 'count-fade 1s ease-out',
          transition: 'font-size 0.3s ease'
        }}>
          {countdown > 0 ? countdown : 'âœ¨'}
        </div>
      </div>
      
      {/* Intention Text */}
      <div style={{
        marginTop: 'var(--space-sm)',
        textAlign: 'center',
        fontSize: '12px',
        fontFamily: 'var(--font-heading)',
        fontWeight: '900',
        color: 'var(--ultra-violet)',
        textTransform: 'uppercase',
        letterSpacing: '0.05em',
        animation: 'fade-in 0.5s ease-out'
      }}>
        {countdown > 0 ? 'Focus your intention' : 'Channeling...'}
      </div>
    </div>
  );
}

// Special Dice Component for refined aesthetic
function NeoDice({ value, isRolling, onClick, disabled }) {
  const getBackgroundColor = () => {
    if (disabled) return 'var(--color-bg-tertiary)';
    if (isRolling) return 'var(--salmon-pink)';
    return 'var(--color-bg-primary)';
  };
  
  const getShadowColor = () => {
    if (isRolling) return 'var(--ultra-violet)';
    return 'var(--moonstone)';
  };
  
  return (
    <div 
      className={`neo-card neo-items-center neo-justify-center ${!disabled ? 'cursor-pointer neo-shake' : 'opacity-50'}`}
      onClick={!disabled ? onClick : undefined}
      style={{
        width: '140px',
        height: '120px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: getBackgroundColor(),
        borderWidth: '4px',
        borderColor: 'var(--color-border)',
        boxShadow: `var(--shadow-offset-x) var(--shadow-offset-y) 0px ${getShadowColor()}`,
        fontSize: value ? '48px' : '32px',
        fontFamily: 'var(--font-heading)',
        fontWeight: '900',
        textTransform: 'uppercase',
        letterSpacing: value ? '0.1em' : '0.05em',
        color: disabled ? 'var(--color-text-muted)' : 'var(--color-text-primary)',
        transition: 'all 0.3s ease',
        padding: '8px'
      }}
    >
      {isRolling ? 'ðŸŽ²' : (value ? value : 'ROLL')}
    </div>
  );
}

// Random.org API Integration
const RANDOM_ORG_BASE = 'https://www.random.org';
const RANDOM_ORG_TIMEOUT = 3000; // 3 second timeout
const RANDOM_ORG_MIN_QUOTA = 100; // Minimum bits required for safe operation
let lastQuotaCheck = 0;
let cachedQuota = null;
const QUOTA_CACHE_DURATION = 60000; // Cache quota for 1 minute

// Check Random.org quota with caching and management
async function checkRandomOrgQuota() {
  try {
    const now = Date.now();
    
    // Use cached quota if recent
    if (cachedQuota !== null && (now - lastQuotaCheck) < QUOTA_CACHE_DURATION) {
      return cachedQuota >= RANDOM_ORG_MIN_QUOTA;
    }
    
    const response = await fetch(`${RANDOM_ORG_BASE}/quota/?format=plain`, {
      method: 'GET',
      signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
    });
    
    if (response.ok) {
      const quota = parseInt(await response.text());
      // Cache the quota result
      cachedQuota = quota;
      lastQuotaCheck = now;
      
      // Log quota status for monitoring
      if (quota < RANDOM_ORG_MIN_QUOTA) {
        console.log(`Random.org quota low: ${quota} bits remaining`);
      }
      
      return quota >= RANDOM_ORG_MIN_QUOTA;
    }
    return false;
  } catch (error) {
    console.warn('Random.org quota check failed:', error);
    // If quota check fails, allow the request to proceed
    // The actual API call will fail if quota is exhausted
    return true;
  }
}

// Fetch true random number from Random.org with enhanced error handling
async function fetchTrueRandomDice() {
  try {
    // Check quota first
    const hasQuota = await checkRandomOrgQuota();
    if (!hasQuota) {
      console.log('Random.org quota insufficient, using fallback');
      return null;
    }

    // Generate random dice roll (1-6)
    const response = await fetch(
      `${RANDOM_ORG_BASE}/integers/?num=1&min=1&max=6&col=1&base=10&format=plain&rnd=new`,
      {
        method: 'GET',
        signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
      }
    );

    if (response.ok) {
      const text = await response.text();
      const result = parseInt(text.trim());
      
      if (!isNaN(result) && result >= 1 && result <= 6) {
        console.log('Random.org dice roll:', result);
        return result;
      } else {
        console.warn('Random.org returned invalid value:', text);
        return null;
      }
    } else if (response.status === 503) {
      console.warn('Random.org service temporarily unavailable');
      return null;
    } else if (response.status === 402) {
      console.warn('Random.org quota exceeded');
      // Reset cached quota
      cachedQuota = 0;
      lastQuotaCheck = Date.now();
      return null;
    }
    
    console.warn('Random.org returned status:', response.status);
    return null;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn('Random.org request timed out');
    } else {
      console.warn('Random.org request failed:', error.message);
    }
    return null;
  }
}

// Fallback to local random generation
function generateLocalRandom() {
  return Math.floor(Math.random() * 6) + 1;
}

// Main random dice function with true random + fallback
async function generateRandomDice() {
  const trueRandom = await fetchTrueRandomDice();
  return trueRandom !== null ? trueRandom : generateLocalRandom();
}

export default function App() {
  const { database, useLiveQuery } = useFireproof("finitude-enhanced")
  const [currentStepIndex, setCurrentStepIndex] = useState(0)
  const [options, setOptions] = useState([])
  const [loading, setLoading] = useState(false)
  const [rolling, setRolling] = useState(false)
  const [diceValue, setDiceValue] = useState(null)
  const [selectedIndex, setSelectedIndex] = useState(null)
  const [vetoUsed, setVetoUsed] = useState(false)
  const [selections, setSelections] = useState({})
  const [rollHistory, setRollHistory] = useState([])
  const [sessionSeed] = useState(Math.floor(Math.random() * 1000000))
  const [sessionTimestamp] = useState(new Date().toISOString())
  const [showResults, setShowResults] = useState(false)
  const [focusingIntention, setFocusingIntention] = useState(false)
  const [intentionCountdown, setIntentionCountdown] = useState(3)
  const animationRef = useRef()
  const intentionTimerRef = useRef()
  
  const steps = [
    { 
      id: 'theme', 
      name: 'Theme', 
      description: 'Core emotional territory',
      prompt: 'Generate minimal, understated themes that suggest emotional territory without being overwrought. Use simple, evocative phrases that leave room for interpretation. Examples: "second language", "borrowed time", "false spring", "exit interview", "muscle memory", "parallel parking", "dead letters", "test pattern". Keep them grounded and specific but not overly poetic. Avoid flowery language.'
    },
    { 
      id: 'symbol', 
      name: 'Symbol Pair', 
      description: 'Two resonant images',
      prompt: 'Create pairs of brief, evocative symbols joined by " + ". Use simple, broadly referential words that carry poetic weight without being precious. Examples: "Moths + Static", "Fever + Maps", "Bridges + Ash", "Windows + Tide", "Keys + Smoke", "Mirrors + Rain". Keep each word short and airy. Avoid overly dramatic or flowery choices - aim for quiet resonance.'
    },
    { 
      id: 'mechanic', 
      name: 'Mechanic', 
      description: 'Musical DNA to borrow',
      prompt: 'Name concrete music mechanics to borrow (rhythm patterns with BPM ranges, bass approaches, harmony concepts, voice techniques, texture ideas, or form structures). Be specific and practical.'
    },
    { 
      id: 'form', 
      name: 'Form', 
      description: 'Song structure',
      prompt: 'Provide compact, readable song forms like "V/CÃ—3 + Bridge", "AABA", "Verse/Verse/Chorus/Verse/Outro". Keep notation clear and standard.'
    },
    { 
      id: 'color', 
      name: 'Color Mood', 
      description: 'Emotional palette',
      prompt: 'Generate color moods with context and hue (like "hospital green", "sunset amber", "midnight purple"). These should evoke specific emotional territories.'
    },
    { 
      id: 'harmony', 
      name: 'Harmony', 
      description: 'Chord approach',
      prompt: 'Suggest compact chord progressions or harmonic approaches. Include specific chords or modal colors. Keep it readable for musicians.'
    },
    { 
      id: 'production', 
      name: 'Production Move', 
      description: 'Signature production technique',
      prompt: 'Describe a single, stageable production move (like "Tape-stop into chorus", "Filter sweep on verses", "Hard pan dialogue"). Be specific about when and how.'
    }
  ]

  const currentStep = steps[currentStepIndex]
  
  // Cleanup timers on unmount
  React.useEffect(() => {
    return () => {
      if (animationRef.current) clearTimeout(animationRef.current)
      if (intentionTimerRef.current) clearInterval(intentionTimerRef.current)
    }
  }, [])
  
  const getFallbackOptions = (stepId) => {
    const fallbacks = {
      theme: [
        { label: "second language", explainer: "Communication barriers and learned behaviors" },
        { label: "borrowed time", explainer: "Temporary states and deadlines" },
        { label: "false spring", explainer: "Premature hope and seasonal confusion" },
        { label: "exit interview", explainer: "Endings and formal closure" },
        { label: "muscle memory", explainer: "Automatic responses and physical knowledge" },
        { label: "parallel parking", explainer: "Small anxieties and urban navigation" }
      ],
      symbol: [
        { label: "Moths + Static", explainer: "Attraction to interference, drawn to noise" },
        { label: "Fever + Maps", explainer: "Delirium and navigation, lost while searching" },
        { label: "Bridges + Ash", explainer: "Connection and aftermath, what remains of crossing" },
        { label: "Windows + Tide", explainer: "Observation and rhythm, watching cycles" },
        { label: "Keys + Smoke", explainer: "Access and dissolution, opening into vapor" },
        { label: "Mirrors + Rain", explainer: "Reflection and obscurity, seeing through weather" }
      ],
      mechanic: [
        { label: "Trap hi-hats at 140 BPM", explainer: "Rolling hi-hat patterns with occasional triplets" },
        { label: "Walking bassline", explainer: "Quarter note bass movement, jazz-influenced" },
        { label: "Call and response vocals", explainer: "Lead line answered by harmony or doubled voice" },
        { label: "Polyrhythm 3:4", explainer: "Three against four rhythm creates tension" },
        { label: "Drop tuning riffs", explainer: "Heavy, low guitar tuning for weight" },
        { label: "Whisper to belt dynamics", explainer: "Extreme vocal dynamic range for impact" }
      ],
      form: [
        { label: "ABABCB", explainer: "Verse/Chorus alternating with a bridge before final chorus" },
        { label: "Through-composed", explainer: "No repeating sections, continuous development" },
        { label: "V/V/C/V/C/C", explainer: "Classic pop structure with double chorus ending" },
        { label: "AABA", explainer: "32-bar standard with contrasting bridge" },
        { label: "Rondo ABACA", explainer: "Main theme returns between new sections" },
        { label: "V/PC/C pattern", explainer: "Verse, pre-chorus, chorus cycle" }
      ],
      color: [
        { label: "Fluorescent white", explainer: "Harsh overhead lighting, office anxiety" },
        { label: "Dawn purple", explainer: "The hope and exhaustion of staying up all night" },
        { label: "Rust orange", explainer: "Decay, autumn, industrial decline" },
        { label: "Ocean gray", explainer: "Vast, neutral, contemplative depth" },
        { label: "Neon pink", explainer: "Artificial vibrancy, night life energy" },
        { label: "Forest green", explainer: "Deep natural sanctuary, growth" }
      ],
      harmony: [
        { label: "i - VI - III - VII", explainer: "Dark modal progression, Dorian-influenced" },
        { label: "I - V - vi - IV", explainer: "Pop progression with emotional resolution" },
        { label: "Pedal tone under moving chords", explainer: "Static bass note creates tension" },
        { label: "ii - V - I jazz cadence", explainer: "Smooth resolution with sophistication" },
        { label: "Chromatic descent", explainer: "Bassline walks down by half steps" },
        { label: "Quartal harmony", explainer: "Chords built in fourths, modern sound" }
      ],
      production: [
        { label: "Reverse reverb on first word", explainer: "Swoosh into each verse for dramatic entry" },
        { label: "Side-chain compression on chorus", explainer: "Everything pumps with the kick drum" },
        { label: "Telephone filter on bridge", explainer: "Lo-fi intimate moment before final chorus" },
        { label: "Vocal chop rhythms", explainer: "Stuttered vocal samples as percussion" },
        { label: "Tape saturation warmth", explainer: "Analog warmth on all tracks" },
        { label: "Hard pan call/response", explainer: "Voices jump left to right in conversation" }
      ]
    }
    
    return fallbacks[stepId] || Array(6).fill(null).map((_, i) => ({
      label: `Option ${i + 1}`,
      explainer: "A creative constraint for your song"
    }))
  }

  useEffect(() => {
    if (currentStepIndex < steps.length && !showResults) {
      loadStepOptions()
    }
  }, [currentStepIndex])

  const loadStepOptions = async () => {
    setLoading(true)
    setOptions([])
    setSelectedIndex(null)
    setDiceValue(null)
    
    const step = steps[currentStepIndex]
    
    try {
      const response = await callAI(`${step.prompt} Generate exactly 6 options. Return as JSON with "label" (the option) and "explainer" (how to use it, under 150 chars) fields.`, {
        schema: {
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  label: { type: "string" },
                  explainer: { type: "string" }
                }
              }
            }
          }
        }
      })
      
      const data = JSON.parse(response)
      const items = (data.items || []).slice(0, 6)
      
      // Pad with fallbacks if needed
      while (items.length < 6) {
        const fallbacks = getFallbackOptions(step.id)
        items.push(fallbacks[items.length])
      }
      
      setOptions(items)
    } catch (error) {
      console.error("Error loading options:", error)
      setOptions(getFallbackOptions(step.id))
    }
    
    setLoading(false)
  }

  const rollDice = async () => {
    if (rolling || focusingIntention || !options.length || selectedIndex !== null) return
    
    // Start intention focusing phase
    setFocusingIntention(true)
    setIntentionCountdown(3)
    
    // Countdown timer
    let countdown = 3
    intentionTimerRef.current = setInterval(() => {
      countdown--
      setIntentionCountdown(countdown)
      
      if (countdown <= 0) {
        clearInterval(intentionTimerRef.current)
        performRoll()
      }
    }, 1000)
  }
  
  const performRoll = async () => {
    setFocusingIntention(false)
    setRolling(true)
    
    // Get true random number from Random.org or fallback
    const roll = await generateRandomDice()
    const index = roll - 1
    
    let animationCount = 0
    const animateRoll = () => {
      animationCount++
      setDiceValue(Math.floor(Math.random() * 6) + 1)
      
      if (animationCount < 10) {
        animationRef.current = setTimeout(animateRoll, 70)
      } else {
        setDiceValue(roll)
        setSelectedIndex(index)
        setRolling(false)
        
        const newSelections = {
          ...selections,
          [currentStep.id]: options[index]
        }
        setSelections(newSelections)
        
        const newHistory = [...rollHistory, { step: currentStep.id, roll, index }]
        setRollHistory(newHistory)
      }
    }
    
    animateRoll()
  }

  const useVeto = async () => {
    if (vetoUsed || selectedIndex === null) return
    setVetoUsed(true)
    setLoading(true)
    
    const vetoedOption = options[selectedIndex]
    const step = steps[currentStepIndex]
    
    try {
      const response = await callAI(`${step.prompt} Generate exactly 1 new option that is different from: "${vetoedOption.label}". Return as JSON with "label" and "explainer" (under 150 chars) fields.`, {
        schema: {
          properties: {
            label: { type: "string" },
            explainer: { type: "string" }
          }
        }
      })
      
      const newOption = JSON.parse(response)
      const newOptions = [...options]
      newOptions[selectedIndex] = newOption
      setOptions(newOptions)
    } catch (error) {
      console.error("Error generating replacement:", error)
      const fallbacks = getFallbackOptions(step.id)
      const newOptions = [...options]
      newOptions[selectedIndex] = fallbacks[(selectedIndex + 3) % 6]
      setOptions(newOptions)
    }
    
    setSelectedIndex(null)
    setDiceValue(null)
    
    const newSelections = { ...selections }
    delete newSelections[currentStep.id]
    setSelections(newSelections)
    setRollHistory(rollHistory.filter(h => h.step !== currentStep.id))
    
    setLoading(false)
  }

  const proceedToNext = async () => {
    if (selectedIndex === null) return
    
    if (currentStepIndex === steps.length - 1) {
      await saveSession()
      setShowResults(true)
    } else {
      setCurrentStepIndex(currentStepIndex + 1)
    }
  }

  const saveSession = async () => {
    await database.put({
      type: 'finitude-session',
      seed: sessionSeed,
      timestamp: sessionTimestamp,
      selections: selections,
      rollHistory: rollHistory,
      completedAt: new Date().toISOString()
    })
  }

  const generateMarkdown = () => {
    let markdown = `# Finitude Session ${sessionSeed}\n${new Date(sessionTimestamp).toLocaleString()}\n\n`
    
    steps.forEach(step => {
      const item = selections[step.id]
      if (item) {
        markdown += `## ${step.name}\n**${item.label}**\n_${item.explainer}_\n\n`
      }
    })
    
    markdown += `---\n_Generated by Finitude_`
    return markdown
  }

  const copyMarkdown = () => {
    navigator.clipboard.writeText(generateMarkdown())
  }

  const { docs: savedSessions } = useLiveQuery("type", { key: "finitude-session", limit: 10, descending: true })

  if (showResults) {
    return (
      <NeoContainer>
        <NeoCard className="neo-mt-lg">
          <NeoCardHeader>
            <div className="neo-flex neo-justify-between neo-items-center">
              <NeoHeading level="xl">ðŸŽµ SONG BLUEPRINT</NeoHeading>
              <div>
                <NeoBadge variant="primary">#{sessionSeed}</NeoBadge>
                <div style={{ fontSize: '12px', marginTop: '4px', color: 'var(--color-text-muted)' }}>
                  {new Date(sessionTimestamp).toLocaleString()}
                </div>
              </div>
            </div>
          </NeoCardHeader>
          
          <NeoCardContent>
            <div className="neo-flex neo-flex-wrap neo-mb-lg" style={{ gap: 'var(--space-xs)' }}>
              {rollHistory.map((h, i) => (
                <div key={i} className="relative">
                  <NeoBadge 
                    variant="accent" 
                    style={{ 
                      fontSize: '18px', 
                      width: '40px', 
                      height: '40px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    {h.roll}
                  </NeoBadge>
                </div>
              ))}
            </div>

            <div className="neo-grid neo-grid-cols-1" style={{ gap: 'var(--space-lg)' }}>
              {steps.map(step => {
                const item = selections[step.id]
                if (!item) return null
                
                return (
                  <NeoCard key={step.id} style={{ 
                    borderLeft: '8px solid var(--color-primary)',
                    backgroundColor: 'var(--color-bg-tertiary)'
                  }}>
                    <NeoCardHeader style={{ marginBottom: 'var(--space-sm)' }}>
                      <NeoHeading level="sm">{step.name}</NeoHeading>
                    </NeoCardHeader>
                    <NeoCardContent>
                      <div style={{ 
                        fontSize: '20px', 
                        fontFamily: 'var(--font-heading)',
                        fontWeight: '900',
                        marginBottom: 'var(--space-sm)',
                        textTransform: 'uppercase'
                      }}>
                        {item.label}
                      </div>
                      <div style={{ 
                        fontSize: '14px',
                        color: 'var(--color-text-muted)',
                        fontStyle: 'italic'
                      }}>
                        {item.explainer}
                      </div>
                    </NeoCardContent>
                  </NeoCard>
                )
              })}
            </div>
          </NeoCardContent>

          <NeoCardFooter>
            <NeoButton onClick={copyMarkdown} variant="accent" size="lg">
              ðŸ“‹ COPY TEXT
            </NeoButton>
            <NeoButton onClick={() => window.print()} variant="neutral" size="lg">
              ðŸ–¨ï¸ PRINT
            </NeoButton>
            <NeoButton onClick={() => window.location.reload()} variant="danger" size="lg">
              ðŸ”„ NEW SESSION
            </NeoButton>
          </NeoCardFooter>
        </NeoCard>
      </NeoContainer>
    )
  }

  return (
    <NeoContainer>
      {/* Banner at top of page */}
      <div style={{ 
        textAlign: 'center', 
        marginBottom: 'var(--space-xl)',
        paddingTop: 'var(--space-md)',
        display: 'flex',
        justifyContent: 'center'
      }}>
        <img 
          src="banner.png" 
          alt="Finitude Banner" 
          style={{
            maxWidth: '600px',
            height: 'auto'
          }}
        />
      </div>
      
      <NeoCard>
        
        <NeoCardContent>
          {/* Veto Button */}
          <div className="neo-flex neo-justify-between neo-items-center neo-mb-lg">
            <NeoBadge variant="neutral">
              Step {currentStepIndex + 1} of {steps.length}
            </NeoBadge>
            <div className="neo-flex">
              {!vetoUsed && selectedIndex !== null && !loading && (
                <NeoButton onClick={useVeto} variant="warning" size="sm">
                  ðŸ”„ VETO & REPLACE
                </NeoButton>
              )}
              {vetoUsed && (
                <NeoBadge variant="neutral">VETO USED</NeoBadge>
              )}
            </div>
          </div>

          {/* Progress Bar */}
          <div className="neo-mb-xl">
            <NeoProgress 
              value={((currentStepIndex + 1) / steps.length) * 100}
              className="neo-mb-sm"
            />
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              fontSize: '12px', 
              color: 'var(--color-text-muted)',
              fontFamily: 'var(--font-heading)',
              fontWeight: '900',
              textTransform: 'uppercase'
            }}>
              <span>Step {currentStepIndex + 1}</span>
              <span>{steps.length} Total</span>
            </div>
          </div>

          {/* Current Step Header */}
          <div style={{ textAlign: 'center', marginBottom: 'var(--space-xl)' }}>
            <NeoHeading level="lg">{currentStep.name}</NeoHeading>
            <div style={{ 
              color: 'var(--color-text-muted)', 
              fontStyle: 'italic',
              fontSize: '16px'
            }}>
              {currentStep.description}
            </div>
          </div>

          {/* Dice Interface / Next Button Area */}
          <div className="neo-flex neo-justify-center neo-mb-xl">
            {selectedIndex !== null && !loading ? (
              // Show Next Button when selection is made
              <NeoButton 
                onClick={proceedToNext}
                variant="success"
                size="lg"
                style={{ fontSize: '20px', padding: '0 var(--space-xl)' }}
              >
                {currentStepIndex === steps.length - 1 ? 'âœ¨ VIEW BLUEPRINT' : 'NEXT STEP â†’'}
              </NeoButton>
            ) : focusingIntention ? (
              // Show intention focus animation
              <IntentionFocus 
                countdown={intentionCountdown}
                onComplete={() => {/* handled in rollDice */}}
              />
            ) : (
              // Show Dice when no selection or loading
              <NeoDice 
                value={diceValue}
                isRolling={rolling}
                onClick={rollDice}
                disabled={selectedIndex !== null || loading || focusingIntention}
              />
            )}
          </div>

          {/* Loading State */}
          {loading && (
            <div style={{ textAlign: 'center', padding: 'var(--space-xl)' }}>
              <NeoAlert variant="warning" title="âœ¨ CRAFTING CONSTRAINTS âœ¨">
                Limiting you in order to set you free
              </NeoAlert>
            </div>
          )}

          {/* Options Grid */}
          {options.length > 0 && !loading && (
            <div className="neo-grid neo-grid-cols-1 neo-mb-lg">
              {options.map((option, i) => {
                const getCardColors = () => {
                  if (selectedIndex === i) {
                    return {
                      bg: 'var(--salmon-pink)',
                      color: 'var(--color-text-inverse)',
                      badgeVariant: 'neutral',
                      shadow: 'var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet)'
                    };
                  }
                  if (selectedIndex !== null) {
                    return {
                      bg: 'var(--color-bg-tertiary)',
                      color: 'var(--color-text-muted)',
                      badgeVariant: 'neutral',
                      shadow: 'var(--shadow-main)'
                    };
                  }
                  
                  // Rotate through refined colors for variety
                  const colors = [
                    { bg: 'var(--lavender-blush)', variant: 'primary' },
                    { bg: 'var(--moonstone)', variant: 'secondary' },
                    { bg: 'var(--color-bg-secondary)', variant: 'accent' },
                    { bg: 'var(--ultra-violet)', variant: 'dark', textColor: 'var(--color-text-inverse)' },
                    { bg: 'var(--salmon-pink)', variant: 'accent', textColor: 'var(--color-text-inverse)' },
                    { bg: 'var(--lavender-blush)', variant: 'pastel' }
                  ];
                  const colorSet = colors[i % colors.length];
                  return {
                    bg: colorSet.bg,
                    color: colorSet.textColor || 'var(--color-text-primary)',
                    badgeVariant: colorSet.variant,
                    shadow: i % 2 === 0 ? 'var(--shadow-main)' : 'var(--shadow-alt)'
                  };
                };
                
                const cardColors = getCardColors();
                
                return (
                  <NeoCard 
                    key={i}
                    style={{
                      backgroundColor: cardColors.bg,
                      opacity: selectedIndex !== null && selectedIndex !== i ? 0.4 : 1,
                      transform: selectedIndex === i ? 'scale(1.02)' : 'scale(1)',
                      transition: 'all 0.3s ease',
                      cursor: selectedIndex === null ? 'pointer' : 'default',
                      color: cardColors.color,
                      boxShadow: cardColors.shadow
                    }}
                    onClick={selectedIndex === null ? () => setSelectedIndex(i) : undefined}
                  >
                    <div className="neo-flex neo-items-center" style={{ gap: 'var(--space-md)' }}>
                      <NeoBadge 
                        variant={cardColors.badgeVariant}
                        style={{ fontSize: '18px', minWidth: '32px', minHeight: '32px' }}
                      >
                        {i + 1}
                      </NeoBadge>
                      <div style={{ flex: 1 }}>
                        <div style={{ 
                          fontFamily: 'var(--font-heading)',
                          fontSize: '18px',
                          fontWeight: '900',
                          marginBottom: 'var(--space-xs)',
                          textTransform: 'uppercase'
                        }}>
                          {option.label}
                        </div>
                        <div style={{ 
                          fontSize: '14px',
                          fontStyle: 'italic',
                          lineHeight: 1.4,
                          opacity: selectedIndex === i ? 0.9 : 0.8
                        }}>
                          {option.explainer}
                        </div>
                      </div>
                    </div>
                  </NeoCard>
                );
              })}
            </div>
          )}

        </NeoCardContent>
      </NeoCard>

      {/* Instructions Card */}
      <NeoCard className="neo-mt-lg">
        <NeoCardHeader>
          <NeoHeading level="md">ðŸ“– HOW IT WORKS</NeoHeading>
        </NeoCardHeader>
        <NeoCardContent>
          <p style={{ lineHeight: 1.6, fontSize: '16px' }}>
            <strong>Quick creative constraints for songwriting.</strong> Click the dice to randomly select from 6 AI-generated options. 
            Each of the 7 steps adds a specific creative constraint. The <strong>Theme</strong> generates minimal phrases like 
            "parallel parking" or "false spring". The <strong>Symbol Pair</strong> offers brief, resonant images like 
            "Moths + Static" or "Fever + Maps"â€”airy words that evoke without overwhelming. You get one veto per session 
            to replace any rolled option.
          </p>
        </NeoCardContent>
      </NeoCard>

      {/* Recent Sessions */}
      {savedSessions.length > 0 && (
        <NeoCard className="neo-mt-lg">
          <NeoCardHeader>
            <NeoHeading level="md">ðŸ• RECENT SESSIONS</NeoHeading>
          </NeoCardHeader>
          <NeoCardContent>
            <div className="neo-grid neo-grid-cols-2">
              {savedSessions.slice(0, 6).map(sess => (
                <NeoBadge 
                  key={sess._id} 
                  variant="secondary"
                  style={{
                    justifyContent: 'space-between',
                    padding: 'var(--space-md)',
                    fontSize: '14px'
                  }}
                >
                  <span style={{ fontWeight: '900' }}>#{sess.seed}</span>
                  <span style={{ fontSize: '12px', opacity: 0.7 }}>
                    {new Date(sess.completedAt || sess.timestamp).toLocaleDateString()}
                  </span>
                </NeoBadge>
              ))}
            </div>
          </NeoCardContent>
        </NeoCard>
      )}
    </NeoContainer>
  )
}
      // prettier-ignore-end

      const rootElement = document.getElementById('container');
      // Check for babel errors before attempting to render
      if (!window.babelTransformError) {
        ReactDOMClient.createRoot(rootElement).render(<App />);
      } else {
        // Create fallback error UI if babel failed
        rootElement.innerHTML = `
          <div style="padding: 20px; color: red; font-family: monospace; white-space: pre-wrap;">
            <h2>Syntax Error</h2>
            <p>${window.babelTransformError.message}</p>
          </div>
        `;
      }
    </script>
  </body>
</html>
