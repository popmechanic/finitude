<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Finitude - Creative Constraints for Songwriting</title>
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Finitude - Creative Constraints for Songwriting" />
    <meta property="og:description" content="A creative constraint tool for songwriters. Generate random prompts across 7 categories to spark your next song." />
    <meta property="og:image" content="https://finitude.music/banner.png" />
    <meta property="og:type" content="website" />
    
    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="/favicon_io/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon_io/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/favicon_io/android-chrome-512x512.png">
    <link rel="manifest" href="/favicon_io/site.webmanifest">
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js"></script>
    <!-- html2canvas-pro handles modern CSS color formats like OKLCH natively -->
    <style>
      /* HYPERPOP-INSPIRED DESIGN SYSTEM */
      :root {
        /* Typography */
        --font-heading: "Arial Black", "Helvetica Bold", system-ui, sans-serif;
        --font-base: "Arial", "Helvetica", system-ui, sans-serif;
        --font-mono: "Courier New", "IBM Plex Mono", monospace;
        
        /* REFINED COLOR PALETTE - Sophisticated & Harmonious */
        
        /* BASE PALETTE - Core Design Colors */
        --ultra-violet: rgba(86, 71, 135, 1);      /* Deep purple - Primary brand */
        --moonstone: rgba(109, 177, 191, 1);       /* Cool blue-green - Secondary */
        --lavender-blush: rgba(255, 234, 236, 1);  /* Soft pink - Light accent */
        --salmon-pink: rgba(243, 154, 157, 1);     /* Warm pink - Vibrant accent */
        --oxford-blue: rgba(16, 25, 53, 1);        /* Deep navy - Dark foundation */
        
        /* SEMANTIC COLORS - Functional application */
        --color-primary: var(--ultra-violet);      /* Primary actions & brand */
        --color-secondary: var(--moonstone);       /* Secondary actions */
        --color-accent: var(--salmon-pink);        /* Highlights & selections */
        --color-warning: rgba(255, 193, 7, 1);     /* Warning yellow */
        --color-danger: rgba(220, 53, 69, 1);      /* Error red */
        --color-success: rgba(40, 167, 69, 1);     /* Success green */
        
        /* BACKGROUNDS - Layered surfaces */
        --color-bg-primary: #ffffff;               /* Pure white for main content */
        --color-bg-secondary: var(--lavender-blush); /* Soft pink for secondary surfaces */
        --color-bg-tertiary: rgba(249, 250, 251, 1); /* Light gray for subtle areas */
        --color-bg-dark: var(--oxford-blue);       /* Dark navy for contrast */
        --color-bg-gradient: linear-gradient(135deg, var(--lavender-blush) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(109, 177, 191, 0.3) 100%);
        
        /* TEXT COLORS - Optimal readability */
        --color-text-primary: var(--oxford-blue);  /* Dark navy for main text */
        --color-text-inverse: #ffffff;             /* White on dark backgrounds */
        --color-text-muted: rgba(86, 71, 135, 0.6); /* Muted ultra-violet */
        --color-text-accent: var(--ultra-violet);  /* Ultra-violet for emphasis */
        
        /* BORDERS & SHADOWS - Refined structure */
        --color-border: var(--oxford-blue);        /* Navy borders for definition */
        --color-border-accent: var(--ultra-violet); /* Purple borders for emphasis */
        --border-width: 3px;                       /* Bold but refined borders */
        --border-radius: 12px;                     /* Soft rounded corners */
        
        /* SHADOWS - Sophisticated depth */
        --shadow-offset-x: 6px;
        --shadow-offset-y: 6px;
        --shadow-color: var(--ultra-violet);       /* Ultra-violet primary shadows */
        --shadow-color-alt: var(--moonstone);      /* Moonstone secondary shadows */
        --shadow-main: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--shadow-color);
        --shadow-alt: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--shadow-color-alt);
        --shadow-hover: 3px 3px 0px var(--shadow-color);
        --shadow-active: 0px 0px 0px var(--shadow-color);
        
        /* SPACING - Consistent scale */
        --space-xs: 4px;
        --space-sm: 8px;
        --space-md: 16px;
        --space-lg: 24px;
        --space-xl: 32px;
        --space-xxl: 48px;
        
        /* Z-INDEX - Layering system */
        --z-tooltip: 1000;
        --z-modal: 2000;
        --z-popover: 3000;
      }
      
      body {
        margin: 0;
        padding: 0;
        font-family: var(--font-base);
        font-weight: 400;
        background: var(--color-bg-gradient);
        color: var(--color-text-primary);
        line-height: 1.4;
      }
      
      #container {
        width: 100%;
        min-height: 100vh;
        background: var(--color-bg-gradient);
        position: relative;
      }
      
      /* Sophisticated background pattern */
      #container::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          radial-gradient(circle at 20% 20%, var(--ultra-violet) 0%, transparent 20%),
          radial-gradient(circle at 80% 80%, var(--moonstone) 0%, transparent 20%),
          radial-gradient(circle at 40% 60%, var(--salmon-pink) 0%, transparent 20%);
        background-size: 200px 200px, 150px 150px, 180px 180px;
        opacity: 0.05;
        pointer-events: none;
        z-index: -1;
      }
      
      /* =================
         NEOBRUTALISM COMPONENTS 
         ================= */
      
      /* Base Button Component */
      .neo-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;
        border-radius: var(--border-radius);
        font-family: var(--font-heading);
        font-weight: 900;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.15s ease-out;
        gap: var(--space-sm);
        cursor: pointer;
        border: var(--border-width) solid var(--color-border);
        box-shadow: var(--shadow-main);
        position: relative;
        user-select: none;
        text-decoration: none;
        min-height: 48px;
        padding: 0 var(--space-lg);
      }
      
      .neo-btn:hover:not(:disabled) {
        transform: translate(calc(var(--shadow-offset-x) / 2), calc(var(--shadow-offset-y) / 2));
        box-shadow: var(--shadow-hover);
      }
      
      .neo-btn:active:not(:disabled) {
        transform: translate(var(--shadow-offset-x), var(--shadow-offset-y));
        box-shadow: var(--shadow-active);
      }
      
      .neo-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      
      /* Button Variants - Refined Color Harmony */
      .neo-btn-primary { 
        background-color: var(--color-primary); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-main);
      }
      .neo-btn-secondary { 
        background-color: var(--color-secondary); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-alt);
      }
      .neo-btn-accent { 
        background-color: var(--color-accent); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-main);
      }
      .neo-btn-warning { 
        background-color: var(--color-warning); 
        color: var(--oxford-blue); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet);
      }
      .neo-btn-danger { 
        background-color: var(--color-danger); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--moonstone);
      }
      .neo-btn-success { 
        background-color: var(--color-success); 
        color: var(--color-text-inverse); 
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--salmon-pink);
      }
      .neo-btn-neutral { 
        background-color: var(--color-bg-primary); 
        color: var(--color-text-primary); 
        box-shadow: var(--shadow-main);
      }
      
      /* Button Sizes */
      .neo-btn-sm { min-height: 36px; padding: 0 var(--space-md); font-size: 14px; }
      .neo-btn-lg { min-height: 56px; padding: 0 var(--space-xl); font-size: 18px; }
      .neo-btn-icon { width: 48px; height: 48px; padding: 0; }
      
      /* Card Component */
      .neo-card {
        background-color: var(--color-bg-primary);
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-main);
        padding: var(--space-xl);
        position: relative;
      }
      
      .neo-card-header {
        margin-bottom: var(--space-lg);
      }
      
      .neo-card-title {
        font-family: var(--font-heading);
        font-size: 24px;
        font-weight: 900;
        margin: 0 0 var(--space-sm) 0;
        text-transform: uppercase;
        letter-spacing: 0.02em;
      }
      
      .neo-card-description {
        color: var(--color-text-muted);
        margin: 0;
        font-size: 16px;
        line-height: 1.5;
      }
      
      .neo-card-content {
        margin-bottom: var(--space-lg);
      }
      
      .neo-card-footer {
        display: flex;
        gap: var(--space-md);
        justify-content: flex-end;
        border-top: var(--border-width) solid var(--color-border);
        padding-top: var(--space-lg);
        margin-top: var(--space-lg);
      }
      
      /* Badge Component */
      .neo-badge {
        display: inline-flex;
        align-items: center;
        border-radius: var(--border-radius);
        border: 2px solid var(--color-border);
        padding: var(--space-xs) var(--space-sm);
        font-family: var(--font-heading);
        font-size: 12px;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      
      .neo-badge-primary { background-color: var(--ultra-violet); color: var(--color-text-inverse); }
      .neo-badge-secondary { background-color: var(--moonstone); color: var(--color-text-inverse); }
      .neo-badge-accent { background-color: var(--salmon-pink); color: var(--color-text-inverse); }
      .neo-badge-neutral { background-color: var(--color-bg-tertiary); color: var(--color-text-primary); }
      .neo-badge-pastel { background-color: var(--lavender-blush); color: var(--color-text-primary); }
      .neo-badge-dark { background-color: var(--oxford-blue); color: var(--color-text-inverse); }
      
      /* Input Component */
      .neo-input {
        width: 100%;
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        padding: var(--space-md);
        font-family: var(--font-base);
        font-size: 16px;
        background-color: var(--color-bg-primary);
        color: var(--color-text-primary);
        box-shadow: var(--shadow-main);
        transition: all 0.15s ease-out;
      }
      
      .neo-input:focus {
        outline: none;
        transform: translate(2px, 2px);
        box-shadow: var(--shadow-hover);
      }
      
      .neo-input::placeholder {
        color: var(--color-text-muted);
        font-style: italic;
      }
      
      /* Alert Component */
      .neo-alert {
        border: var(--border-width) solid var(--color-border);
        border-radius: var(--border-radius);
        padding: var(--space-lg);
        background-color: var(--color-bg-primary);
        box-shadow: var(--shadow-main);
        position: relative;
      }
      
      .neo-alert-title {
        font-family: var(--font-heading);
        font-size: 18px;
        font-weight: 900;
        margin: 0 0 var(--space-sm) 0;
        text-transform: uppercase;
      }
      
      .neo-alert-description {
        margin: 0;
        line-height: 1.5;
      }
      
      .neo-alert-warning {
        background-color: var(--color-warning);
        border-color: var(--ultra-violet);
        color: var(--oxford-blue);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet);
      }
      
      .neo-alert-danger {
        background-color: var(--color-danger);
        border-color: var(--moonstone);
        color: var(--color-text-inverse);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--moonstone);
      }
      
      .neo-alert-success {
        background-color: var(--color-success);
        border-color: var(--salmon-pink);
        color: var(--color-text-inverse);
        box-shadow: var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--salmon-pink);
      }
      
      /* Typography */
      .neo-heading {
        font-family: var(--font-heading);
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        margin: 0 0 var(--space-md) 0;
      }
      
      .neo-heading-xl { font-size: 48px; line-height: 1.1; }
      .neo-heading-lg { font-size: 36px; line-height: 1.2; }
      .neo-heading-md { font-size: 24px; line-height: 1.3; }
      .neo-heading-sm { font-size: 18px; line-height: 1.4; }
      
      /* Layout Utilities */
      .neo-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--space-xl);
      }
      
      .neo-grid {
        display: grid;
        gap: var(--space-lg);
      }
      
      .neo-grid-cols-1 { grid-template-columns: 1fr; }
      .neo-grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
      .neo-grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
      
      .neo-flex {
        display: flex;
        gap: var(--space-md);
      }
      
      .neo-flex-col { flex-direction: column; }
      .neo-flex-wrap { flex-wrap: wrap; }
      .neo-justify-center { justify-content: center; }
      .neo-justify-between { justify-content: space-between; }
      .neo-items-center { align-items: center; }
      
      /* Spacing Utilities */
      .neo-mb-xs { margin-bottom: var(--space-xs); }
      .neo-mb-sm { margin-bottom: var(--space-sm); }
      .neo-mb-md { margin-bottom: var(--space-md); }
      .neo-mb-lg { margin-bottom: var(--space-lg); }
      .neo-mb-xl { margin-bottom: var(--space-xl); }
      
      .neo-mt-xs { margin-top: var(--space-xs); }
      .neo-mt-sm { margin-top: var(--space-sm); }
      .neo-mt-md { margin-top: var(--space-md); }
      .neo-mt-lg { margin-top: var(--space-lg); }
      .neo-mt-xl { margin-top: var(--space-xl); }
      
      /* Special Effects */
      .neo-shake:hover {
        animation: shake 0.5s ease-in-out;
      }
      
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-2px); }
        75% { transform: translateX(2px); }
      }
      
      /* Breathing animation for intention focus */
      @keyframes breathe {
        0%, 100% { 
          transform: scale(1);
          opacity: 0.9;
        }
        50% { 
          transform: scale(1.15);
          opacity: 1;
        }
      }
      
      /* Pulse ring animation */
      @keyframes pulse-ring {
        0% {
          transform: scale(1);
          opacity: 0.4;
        }
        100% {
          transform: scale(1.4);
          opacity: 0;
        }
      }
      
      /* Fade in animation */
      @keyframes fade-in {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      /* Count fade animation */
      @keyframes count-fade {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      
      /* Print-specific styles for compact single-page layout */
      @media print {
        /* Reset page margins and size */
        @page {
          size: letter;
          margin: 0.5in;
        }
        
        /* Hide non-essential elements */
        .neo-container > div:first-child, /* Banner image */
        button,
        .neo-card-footer,
        .neo-alert,
        .neo-badge[style*="40px"], /* Dice roll badges */
        [style*="gap: var(--space-xs)"] /* Dice roll container */
        {
          display: none !important;
        }
        
        /* Reset base styles for print */
        * {
          color: black !important;
          background: white !important;
          box-shadow: none !important;
          text-shadow: none !important;
        }
        
        /* Compact container */
        .neo-container {
          padding: 0 !important;
          max-width: 100% !important;
        }
        
        /* Compact main card */
        .neo-card {
          border: 1px solid #ccc !important;
          margin: 0 !important;
          padding: 0 !important;
        }
        
        /* Compact header */
        .neo-card-header {
          padding: 8px !important;
          border-bottom: 1px solid #ccc !important;
        }
        
        .neo-heading[level="xl"] {
          font-size: 18px !important;
          margin: 0 !important;
        }
        
        /* Session info */
        .neo-badge[variant="primary"] {
          display: inline !important;
          font-size: 14px !important;
          padding: 2px 6px !important;
          border: 1px solid #ccc !important;
          margin-left: 8px !important;
        }
        
        /* Timestamp */
        [style*="fontSize: '12px'"] {
          display: none !important; /* Hide timestamp to save space */
        }
        
        /* Content area */
        .neo-card-content {
          padding: 8px !important;
        }
        
        /* Constraint items grid - make more compact */
        .neo-grid {
          display: grid !important;
          grid-template-columns: 1fr 1fr !important; /* 2 columns for 7 items */
          gap: 8px !important;
          margin: 0 !important;
        }
        
        /* Individual constraint cards */
        .neo-grid .neo-card {
          border-left: 3px solid #333 !important;
          padding: 6px !important;
          margin: 0 !important;
          page-break-inside: avoid;
        }
        
        /* Constraint headers */
        .neo-grid .neo-card-header {
          padding: 0 0 4px 0 !important;
          border: none !important;
          margin: 0 !important;
        }
        
        .neo-heading[level="sm"] {
          font-size: 11px !important;
          font-weight: bold !important;
          text-transform: uppercase !important;
          margin: 0 !important;
        }
        
        /* Constraint content */
        .neo-grid .neo-card-content {
          padding: 0 !important;
        }
        
        /* Constraint label */
        [style*="fontSize: '20px'"] {
          font-size: 13px !important;
          font-weight: bold !important;
          margin-bottom: 2px !important;
          line-height: 1.2 !important;
        }
        
        /* Constraint explainer */
        [style*="fontSize: '14px'"][style*="italic"] {
          font-size: 10px !important;
          line-height: 1.3 !important;
          font-style: normal !important;
          color: #666 !important;
        }
        
        /* Ensure single page */
        body {
          margin: 0 !important;
          padding: 0 !important;
        }
        
        /* Force page breaks */
        .neo-container {
          page-break-after: avoid !important;
        }
      }
    </style>
    <script>
      const activeRequests = new Set();
      let lastState = null;

      function updateStreamingState() {
        const currentState = activeRequests.size > 0;
        if (currentState !== lastState) {
          lastState = currentState;
          window.parent.postMessage({ type: 'streaming', state: currentState }, '*');
        }
      }

      const originalFetch = window.fetch;
      window.fetch = (...args) => {
        const reqInfo = args[0];
        activeRequests.add(reqInfo);
        updateStreamingState();

        return originalFetch(...args).then((res) => {
          if (!res.body) {
            activeRequests.delete(reqInfo);
            updateStreamingState();
            return res;
          }
          const reader = res.body.getReader();
          const stream = new ReadableStream({
            start(controller) {
              function pump() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    activeRequests.delete(reqInfo);
                    updateStreamingState();
                    controller.close();
                    return;
                  }
                  controller.enqueue(value);
                  pump();
                });
              }
              pump();
            },
          });
          return new Response(stream, { headers: res.headers });
        });
      };

      // Screenshot functionality
      function cropToMaxAspectRatio(canvas, maxAspectRatio) {
        const width = canvas.width;
        const height = canvas.height;
        const currentAspectRatio = height / width;

        // If already within the max aspect ratio, return original canvas
        if (currentAspectRatio <= maxAspectRatio) {
          return canvas;
        }

        // Calculate new dimensions - crop from the bottom
        const newHeight = width * maxAspectRatio;
        const cropY = 0; // Start from top

        // Create new canvas with cropped dimensions
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = width;
        croppedCanvas.height = newHeight;

        const ctx = croppedCanvas.getContext('2d');

        // Draw cropped portion of original canvas
        ctx.drawImage(
          canvas,
          0,
          cropY,
          width,
          newHeight, // Source rectangle (crop from original)
          0,
          0,
          width,
          newHeight // Destination rectangle (full new canvas)
        );

        return croppedCanvas;
      }

      function captureScreenshot() {
        // Check if html2canvas is loaded
        if (typeof html2canvas === 'undefined') {
          // Try to load html2canvas-pro dynamically
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js';
          script.onload = () => {
            captureScreenshotWithFallback();
          };
          script.onerror = (e) => {
            window.parent.postMessage(
              { type: 'screenshot-error', error: 'Failed to load html2canvas' },
              '*'
            );
          };
          document.head.appendChild(script);
          return;
        }

        captureScreenshotWithFallback();
      }

      function captureScreenshotWithFallback() {
        try {
          // Let html2canvas-pro do its job with modern CSS
          html2canvas(document.body, {
            allowTaint: true,
            useCORS: true,
            scale: 1,
            logging: false,
          })
            .then((canvas) => {
              // Crop to max 3:1 aspect ratio (3 times taller than wide)
              const croppedCanvas = cropToMaxAspectRatio(canvas, 3);
              const dataURI = croppedCanvas.toDataURL();
              window.parent.postMessage({ type: 'screenshot', data: dataURI }, '*');
            })
            .catch((err) => {
              window.parent.postMessage(
                {
                  type: 'screenshot-error',
                  error: 'Screenshot capture failed: ' + (err.message || 'Unknown error'),
                },
                '*'
              );
            });
        } catch (err) {
          window.parent.postMessage(
            {
              type: 'screenshot-error',
              error: 'Unexpected error during screenshot capture',
            },
            '*'
          );
        }
      }

      function pageIsLoaded() {
        window.parent.postMessage({ type: 'preview-ready' }, '*');
        setTimeout(captureScreenshot, 2000);
      }

      // For rapid updates (optional)
      let currentApp = null;
      function updateAppComponent(code) {
        try {
          // Evaluate new component code
          eval(code);

          // If we implement rapid updates, we'll need to re-render here
          if (currentApp && window.ReactDOM) {
            // Re-render with new component
          }

          return true;
        } catch (error) {
          console.error('Failed to update component:', error);
          return false;
        }
      }

      // Event listeners
      window.addEventListener('message', function (event) {
        if (event.data) {
          if (event.data.type === 'command') {
            if (event.data.command === 'capture-screenshot') {
              captureScreenshot();
            }
          } else if (event.data.type === 'callai-api-key' && event.data.key) {
            window.CALLAI_API_KEY = event.data.key;
          }
        }
      });

      window.addEventListener('DOMContentLoaded', function () {
        pageIsLoaded();
      });

      // Global error handlers to catch and log all errors
      window.onerror = function (message, source, lineno, colno, error) {
        const errorDetails = {
          type: 'error',
          message: message,
          source: source,
          lineno: lineno,
          colno: colno,
          stack: error?.stack || 'No stack trace available',
          timestamp: new Date().toISOString(),
        };
        console.error('Uncaught error:', errorDetails);
        // Send error to parent window
        window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
        return false; // Let the default error handler run
      };

      // Handle unhandled promise rejections
      window.addEventListener('unhandledrejection', function (event) {
        const errorDetails = {
          type: 'unhandledrejection',
          reason: event.reason?.toString() || 'Unknown reason',
          stack: event.reason?.stack || 'No stack trace available',
          timestamp: new Date().toISOString(),
        };
        // Send rejection to parent window
        window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
      });
    </script>
  </head>
  <body>
    <div id="container"></div>
    <script>
      window.CALLAI_API_KEY = 'sk-vibes-proxy-managed';
      window.SESSION_ID = 'fmejcgpq8ncqrglokd';
      window.CALLAI_CHAT_URL = 'https://vibes-diy-api.com';
      window.CALLAI_IMG_URL = 'https://vibes-diy-api.com';
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.1/es2022/react.mjs",
          "react-dom": "https://esm.sh/react-dom@19.1.1/es2022/react-dom.mjs",
          "react-dom/client": "https://esm.sh/react-dom@19.1.1/es2022/client.mjs",
          "use-fireproof": "https://esm.sh/use-fireproof@0.23.0",
          "call-ai": "https://esm.sh/call-ai",
          "use-vibes": "https://esm.sh/use-vibes",
          "three": "https://esm.sh/three"
        }
      }
    </script>

    <!-- Enhanced Babel and JSX error handling script -->
    <script>
      window.babelTransformError = null;

      // 1. Patch console.error to capture JSX parse errors that are only logged to console
      const originalConsoleError = console.error;
      console.error = function (...args) {
        const errorMsg = args.join(' ');

        // Look for specific JSX parse errors that might not trigger other handlers
        if (
          errorMsg.includes('parse-error.ts') ||
          (errorMsg.includes('SyntaxError') && errorMsg.includes('Unexpected token')) ||
          errorMsg.includes('JSX')
        ) {
          // Extract line and position information if available
          let lineInfo = '';
          const lineMatch =
            errorMsg.match(/(\d+):(\d+)/) || errorMsg.match(/line (\d+).+column (\d+)/);
          if (lineMatch) {
            lineInfo = ` at line ${lineMatch[1]}, column ${lineMatch[2]}`;
          }

          // Extract meaningful error message
          let message = 'JSX Syntax Error';
          if (errorMsg.includes('Unexpected token')) {
            const tokenMatch = errorMsg.match(/Unexpected token[,:]?\s*([^,\n\)]+)/);
            if (tokenMatch) {
              message = `JSX Syntax Error: Unexpected token ${tokenMatch[1].trim()}`;
            }
          } else if (errorMsg.includes('expected')) {
            const expectedMatch = errorMsg.match(/expected\s+([^,\n\)]+)/);
            if (expectedMatch) {
              message = `JSX Syntax Error: Expected ${expectedMatch[1].trim()}`;
            }
          }

          const errorDetails = {
            type: 'error',
            message: `${message}${lineInfo}`,
            source: 'jsx-parser',
            stack: errorMsg,
            timestamp: new Date().toISOString(),
            errorType: 'SyntaxError',
          };

          // Only send if we haven't already reported an error
          if (!window.babelTransformError) {
            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
          }
        }

        // Call original console.error
        originalConsoleError.apply(console, args);
      };

      // 2. Patch Babel transform for errors caught during transformation
      if (window.Babel && window.Babel.transform) {
        const originalTransform = window.Babel.transform;
        window.Babel.transform = function (code, options) {
          try {
            return originalTransform.call(this, code, options);
          } catch (err) {
            // Capture and format Babel error
            const errorDetails = {
              type: 'error',
              message: `Babel Syntax Error: ${err.message || 'Invalid syntax'}`,
              source: 'babel-transform',
              stack: err.stack || '',
              timestamp: new Date().toISOString(),
              errorType: 'SyntaxError',
            };
            // Report error to parent
            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
            throw err;
          }
        };
      }

      // 3. Enhanced unhandled error handler specifically for syntax errors
      window.addEventListener(
        'error',
        function (event) {
          // Skip if we already caught the error elsewhere
          if (window.babelTransformError) return;

          // Focus on syntax errors and parse errors
          if (
            event.error?.stack?.includes('parse-error.ts') ||
            event.message?.includes('SyntaxError') ||
            (event.message === 'Script error.' && !event.filename)
          ) {
            let message = event.message;
            if (message === 'Script error.') {
              message = 'JSX Syntax Error: Unable to parse JSX code';
            }

            const errorDetails = {
              type: 'error',
              message: message,
              source: event.filename || 'jsx-parser',
              lineno: event.lineno || 0,
              colno: event.colno || 0,
              stack: event.error?.stack || '',
              timestamp: new Date().toISOString(),
              errorType: 'SyntaxError',
            };

            window.parent.postMessage({ type: 'iframe-error', error: errorDetails }, '*');
            window.babelTransformError = errorDetails;
          }
        },
        true
      );
    </script>

    <script type="text/babel" data-type="module">
      import ReactDOMClient from 'react-dom/client';

      // App runs normally without our interference, but the iframe loads our script to modify use-fireproof
      // prettier-ignore
      import React, { useState, useEffect, useRef } from "react"
import { callAI } from "call-ai"
import { useFireproof } from "use-fireproof"

// ===========================
// NEOBRUTALISM COMPONENTS
// ===========================

// Button Component
function NeoButton({ 
  children, 
  onClick, 
  variant = 'primary', 
  size = 'md', 
  disabled = false, 
  className = '', 
  ...props 
}) {
  const classes = `neo-btn neo-btn-${variant} neo-btn-${size} ${className}`.trim();
  
  return (
    <button 
      className={classes}
      onClick={onClick}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
}

// Card Component
function NeoCard({ children, className = '', ...props }) {
  return (
    <div className={`neo-card ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardHeader({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-header ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardTitle({ children, className = '', ...props }) {
  return (
    <h3 className={`neo-card-title ${className}`} {...props}>
      {children}
    </h3>
  );
}

function NeoCardDescription({ children, className = '', ...props }) {
  return (
    <p className={`neo-card-description ${className}`} {...props}>
      {children}
    </p>
  );
}

function NeoCardContent({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-content ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoCardFooter({ children, className = '', ...props }) {
  return (
    <div className={`neo-card-footer ${className}`} {...props}>
      {children}
    </div>
  );
}

// Badge Component
function NeoBadge({ children, variant = 'neutral', className = '', ...props }) {
  const classes = `neo-badge neo-badge-${variant} ${className}`.trim();
  
  return (
    <span className={classes} {...props}>
      {children}
    </span>
  );
}

// Heading Component
function NeoHeading({ children, level = 'md', className = '', ...props }) {
  const classes = `neo-heading neo-heading-${level} ${className}`.trim();
  const Tag = level === 'xl' || level === 'lg' ? 'h1' : 
             level === 'md' ? 'h2' : 'h3';
  
  return (
    <Tag className={classes} {...props}>
      {children}
    </Tag>
  );
}

// Alert Component
function NeoAlert({ children, variant = 'default', title, className = '', ...props }) {
  const classes = `neo-alert ${variant !== 'default' ? `neo-alert-${variant}` : ''} ${className}`.trim();
  
  return (
    <div className={classes} {...props}>
      {title && <div className="neo-alert-title">{title}</div>}
      <div className="neo-alert-description">
        {children}
      </div>
    </div>
  );
}

// Container Component
function NeoContainer({ children, className = '', ...props }) {
  return (
    <div className={`neo-container ${className}`} {...props}>
      {children}
    </div>
  );
}

// Accordion Component (neobrutalism style)
function NeoAccordion({ children, className = '', ...props }) {
  return (
    <div className={`neo-accordion ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoAccordionItem({ children, className = '', ...props }) {
  return (
    <div className={`neo-accordion-item ${className}`} {...props}>
      {children}
    </div>
  );
}

function NeoAccordionTrigger({ children, isOpen, onClick, className = '', ...props }) {
  return (
    <button
      className={`neo-accordion-trigger ${className}`}
      onClick={onClick}
      style={{
        width: '100%',
        padding: 'var(--space-md)',
        backgroundColor: isOpen ? 'var(--color-primary)' : 'var(--color-bg-secondary)',
        color: isOpen ? 'white' : 'var(--color-text)',
        border: 'var(--border-width) solid var(--color-border)',
        borderRadius: 'var(--border-radius)',
        fontFamily: 'var(--font-base)',  // Changed to base font for better readability
        fontWeight: '700',  // Reduced from 900 to 700 for better legibility
        fontSize: '15px',  // Slightly larger for better readability
        letterSpacing: '-0.01em',  // Slight letter spacing adjustment
        textAlign: 'left',
        cursor: 'pointer',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        transition: 'all 0.2s ease',
        boxShadow: isOpen ? 'var(--shadow-sm)' : 'none',
        marginBottom: isOpen ? '0' : 'var(--space-xs)'
      }}
      {...props}
    >
      <span>{children}</span>
      <span style={{
        transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
        transition: 'transform 0.2s ease',
        fontSize: '12px',
        opacity: 0.7
      }}>▼</span>
    </button>
  );
}

function NeoAccordionContent({ children, isOpen, className = '', ...props }) {
  if (!isOpen) return null;
  
  return (
    <div 
      className={`neo-accordion-content ${className}`}
      style={{
        padding: 'var(--space-md)',
        backgroundColor: 'var(--color-bg-tertiary)',
        border: 'var(--border-width) solid var(--color-border)',
        borderTop: 'none',
        borderRadius: '0 0 var(--border-radius) var(--border-radius)',
        marginBottom: 'var(--space-sm)'
      }}
      {...props}
    >
      {children}
    </div>
  );
}

// Progress Component (adapted from neobrutalism library)
function NeoProgress({ value, className = '', ...props }) {
  return (
    <div
      className={`neo-progress ${className}`}
      style={{
        position: 'relative',
        height: '16px',
        width: '100%',
        overflow: 'hidden',
        borderRadius: 'var(--border-radius)',
        border: 'var(--border-width) solid var(--color-border)',
        backgroundColor: 'var(--color-bg-tertiary)'
      }}
      {...props}
    >
      <div
        className="neo-progress-indicator"
        style={{
          height: '100%',
          width: '100%',
          flex: 1,
          borderRight: value < 100 ? 'var(--border-width) solid var(--color-border)' : 'none',
          backgroundColor: 'var(--salmon-pink)',
          transition: 'all 0.3s ease',
          transform: `translateX(-${100 - (value || 0)}%)`
        }}
      />
    </div>
  );
}

// Initial Intention Component for master seed generation
function InitialIntention({ onComplete }) {
  const [countdown, setCountdown] = useState(0);
  const [focusing, setFocusing] = useState(false);
  const [ready, setReady] = useState(false);
  const [selectedConstraints, setSelectedConstraints] = useState({
    'neogenre': true,
    'theme': true,
    'symbol': true,
    'mechanic': true,
    'form': true,
    'color': true,
    'harmony': true,
    'production': true
  });
  const timerRef = useRef();
  
  const constraintInfo = {
    'neogenre': {
      name: 'Neo-Genre',
      description: 'Invent a genre that doesn\'t exist yet'
    },
    'theme': { 
      name: 'Theme', 
      description: 'Core emotional territory to explore'
    },
    'symbol': { 
      name: 'Symbol Pair', 
      description: 'Two resonant images to weave through your lyrics'
    },
    'mechanic': { 
      name: 'Mechanic', 
      description: 'Musical DNA to borrow (rhythm, harmony, texture)'
    },
    'form': { 
      name: 'Form', 
      description: 'Song structure blueprint'
    },
    'color': { 
      name: 'Color Mood', 
      description: 'Emotional palette and atmosphere'
    },
    'harmony': { 
      name: 'Harmony', 
      description: 'Chord progressions and harmonic approach'
    },
    'production': { 
      name: 'Production Move', 
      description: 'Signature production technique to apply'
    }
  };
  
  const toggleConstraint = (id) => {
    setSelectedConstraints(prev => ({
      ...prev,
      [id]: !prev[id]
    }));
  };
  
  const getSelectedCount = () => {
    return Object.values(selectedConstraints).filter(v => v).length;
  };
  
  const startFocus = async () => {
    const selectedCount = getSelectedCount();
    if (selectedCount === 0) {
      alert('Please select at least one constraint to begin the ritual.');
      return;
    }
    
    setFocusing(true);
    setCountdown(5);
    
    // Start countdown
    let count = 5;
    timerRef.current = setInterval(() => {
      count--;
      setCountdown(count);
      
      if (count <= 0) {
        clearInterval(timerRef.current);
        completeFocus();
      }
    }, 1000);
  };
  
  const completeFocus = async () => {
    // Fetch master seed and temperature
    const seed = await fetchMasterSeed();
    const temp = await fetchTemperatureBase();
    
    // Brief pause before transitioning
    setTimeout(() => {
      onComplete(seed, temp, selectedConstraints);
    }, 500);
  };
  
  React.useEffect(() => {
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);
  
  if (!ready) {
    return (
      <div style={{
        minHeight: '100vh',
        padding: 'var(--space-xl)'
      }}>
        {/* Banner at top of page */}
        <div style={{ 
          textAlign: 'center', 
          marginBottom: 'var(--space-xl)',
          paddingTop: 'var(--space-md)',
          display: 'flex',
          justifyContent: 'center'
        }}>
          <img 
            src="banner.png" 
            alt="Finitude Banner" 
            style={{
              maxWidth: '600px',
              height: 'auto'
            }}
          />
        </div>
        
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <NeoCard style={{ maxWidth: '700px', textAlign: 'center' }}>
            <NeoCardContent>
              <div style={{
              padding: 'var(--space-lg)',
              background: 'var(--lavender-blush)',
              borderRadius: 'var(--border-radius)',
              border: 'var(--border-width) solid var(--color-border)',
              marginBottom: 'var(--space-xl)'
            }}>
              <p style={{ 
                fontSize: '16px',
                lineHeight: 1.6,
                marginBottom: 'var(--space-lg)',
                fontWeight: '600'
              }}>
                Choose Your Constraints
              </p>
              <p style={{
                fontSize: '14px',
                color: 'var(--color-text-muted)',
                marginBottom: 'var(--space-lg)'
              }}>
                Select the creative boundaries you want to explore. You can choose between 1 and 7 constraints for your session.
              </p>
              
              <div style={{
                display: 'grid',
                gap: 'var(--space-sm)',
                textAlign: 'left',
                maxWidth: '500px',
                margin: '0 auto'
              }}>
                {Object.entries(constraintInfo).map(([id, info]) => (
                  <label
                    key={id}
                    style={{
                      display: 'flex',
                      alignItems: 'flex-start',
                      gap: 'var(--space-sm)',
                      padding: 'var(--space-sm)',
                      borderRadius: 'var(--border-radius)',
                      cursor: 'pointer',
                      transition: 'background 0.2s ease',
                      background: selectedConstraints[id] ? 'rgba(255, 255, 255, 0.8)' : 'transparent'
                    }}
                  >
                    <input
                      type="checkbox"
                      checked={selectedConstraints[id]}
                      onChange={() => toggleConstraint(id)}
                      style={{
                        marginTop: '2px',
                        width: '20px',
                        height: '20px',
                        cursor: 'pointer',
                        accentColor: 'var(--ultra-violet)'
                      }}
                    />
                    <div style={{ flex: 1 }}>
                      <div style={{
                        fontFamily: 'var(--font-heading)',
                        fontWeight: '900',
                        fontSize: '14px',
                        textTransform: 'uppercase',
                        marginBottom: '2px',
                        color: selectedConstraints[id] ? 'var(--ultra-violet)' : 'var(--color-text-primary)'
                      }}>
                        {info.name}
                      </div>
                      <div style={{
                        fontSize: '12px',
                        color: 'var(--color-text-muted)',
                        lineHeight: 1.3
                      }}>
                        {info.description}
                      </div>
                    </div>
                  </label>
                ))}
              </div>
              
              <div style={{
                marginTop: 'var(--space-lg)',
                padding: 'var(--space-sm)',
                background: 'var(--color-bg-primary)',
                borderRadius: 'var(--border-radius)',
                border: '2px solid var(--color-border)'
              }}>
                <div style={{
                  fontSize: '14px',
                  fontWeight: '600',
                  color: getSelectedCount() > 0 ? 'var(--ultra-violet)' : 'var(--color-danger)'
                }}>
                  {getSelectedCount() === 0 
                    ? 'Select at least 1 constraint to begin'
                    : `${getSelectedCount()} constraint${getSelectedCount() !== 1 ? 's' : ''} selected`
                  }
                </div>
              </div>
            </div>
            
              <NeoButton 
                onClick={() => setReady(true)}
                variant="primary"
                size="lg"
                style={{ fontSize: '18px' }}
                disabled={getSelectedCount() === 0}
              >
                BEGIN RITUAL
              </NeoButton>
            </NeoCardContent>
          </NeoCard>
        </div>
      </div>
    );
  }
  
  if (!focusing) {
    return (
      <div style={{
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 'var(--space-xl)'
      }}>
        <NeoCard style={{ maxWidth: '500px', textAlign: 'center' }}>
          <NeoCardContent>
            <NeoHeading level="lg" style={{ marginBottom: 'var(--space-lg)' }}>
              Set Your Intention
            </NeoHeading>
            <p style={{ 
              fontSize: '16px',
              marginBottom: 'var(--space-xl)',
              lineHeight: 1.6
            }}>
              Focus on what you want to create today. 
              Let your intention guide the constraints.
            </p>
            <NeoButton 
              onClick={startFocus}
              variant="success"
              size="lg"
              style={{ fontSize: '18px' }}
            >
              FOCUS INTENTION
            </NeoButton>
          </NeoCardContent>
        </NeoCard>
      </div>
    );
  }
  
  // Focusing state with animation
  return (
    <div style={{
      minHeight: '100vh',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      padding: 'var(--space-xl)',
      background: `linear-gradient(135deg, var(--lavender-blush) 0%, var(--color-bg) 100%)`
    }}>
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: 'var(--space-lg)'
      }}>
        {/* Large breathing circle */}
        <div style={{
          width: '120px',
          height: '120px',
          borderRadius: '50%',
          background: countdown > 0 ? 'var(--moonstone)' : 'var(--salmon-pink)',
          border: 'var(--border-width) solid var(--color-border)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          animation: 'breathe 2s ease-in-out infinite',
          boxShadow: 'var(--shadow-main)',
          position: 'relative',
          transition: 'all 0.5s ease'
        }}>
          {/* Multiple pulse rings */}
          <div style={{
            position: 'absolute',
            top: '-12px',
            left: '-12px',
            right: '-12px',
            bottom: '-12px',
            borderRadius: '50%',
            border: '4px solid var(--salmon-pink)',
            animation: 'pulse-ring 2s ease-out infinite',
            opacity: 0.6
          }} />
          <div style={{
            position: 'absolute',
            top: '-24px',
            left: '-24px',
            right: '-24px',
            bottom: '-24px',
            borderRadius: '50%',
            border: '2px solid var(--ultra-violet)',
            animation: 'pulse-ring 2s ease-out infinite 0.5s',
            opacity: 0.4
          }} />
          
          <div style={{
            fontSize: countdown > 0 ? '48px' : '32px',
            color: 'var(--color-text-inverse)',
            fontFamily: 'var(--font-heading)',
            fontWeight: '900',
            animation: 'count-fade 1s ease-out',
            transition: 'font-size 0.5s ease'
          }}>
            {countdown > 0 ? countdown : '✨'}
          </div>
        </div>
        
        {/* Status text */}
        <div style={{
          textAlign: 'center',
          animation: 'fade-in 0.5s ease-out'
        }}>
          <div style={{
            fontSize: '20px',
            fontFamily: 'var(--font-heading)',
            fontWeight: '900',
            color: 'var(--ultra-violet)',
            textTransform: 'uppercase',
            marginBottom: 'var(--space-sm)'
          }}>
            {countdown > 3 ? 'Channeling Creative Energy' : 
             countdown > 0 ? 'Seeding Possibility Space' : 
             'Preparing Your Constraints'}
          </div>
          <div style={{
            fontSize: '14px',
            color: 'var(--color-text-muted)',
            fontStyle: 'italic'
          }}>
            Focus your intention...
          </div>
        </div>
      </div>
    </div>
  );
}

// Intention Focus Component with breathing animation (for dice rolls)
function IntentionFocus({ countdown, onComplete }) {
  React.useEffect(() => {
    if (countdown <= 0) {
      onComplete();
    }
  }, [countdown, onComplete]);

  return (
    <div style={{
      width: '140px',
      height: '120px',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'relative'
    }}>
      {/* Breathing Circle Animation */}
      <div style={{
        width: '80px',
        height: '80px',
        borderRadius: '50%',
        background: countdown > 0 ? 'var(--moonstone)' : 'var(--salmon-pink)',
        border: 'var(--border-width) solid var(--color-border)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        animation: 'breathe 2s ease-in-out infinite',
        boxShadow: 'var(--shadow-main)',
        position: 'relative',
        transition: 'background 0.3s ease'
      }}>
        {/* Pulse ring effect */}
        <div style={{
          position: 'absolute',
          top: '-8px',
          left: '-8px',
          right: '-8px',
          bottom: '-8px',
          borderRadius: '50%',
          border: '3px solid var(--salmon-pink)',
          animation: 'pulse-ring 1.5s ease-out infinite',
          opacity: 0.4
        }} />
        
        <div style={{
          fontSize: countdown > 0 ? '32px' : '24px',
          color: 'var(--color-text-inverse)',
          fontFamily: 'var(--font-heading)',
          fontWeight: '900',
          animation: 'count-fade 1s ease-out',
          transition: 'font-size 0.3s ease'
        }}>
          {countdown > 0 ? countdown : '✨'}
        </div>
      </div>
      
      {/* Intention Text */}
      <div style={{
        marginTop: 'var(--space-sm)',
        textAlign: 'center',
        fontSize: '12px',
        fontFamily: 'var(--font-heading)',
        fontWeight: '900',
        color: 'var(--ultra-violet)',
        textTransform: 'uppercase',
        letterSpacing: '0.05em',
        animation: 'fade-in 0.5s ease-out'
      }}>
        {countdown > 0 ? 'Focus your intention' : 'Channeling...'}
      </div>
    </div>
  );
}

// Special Dice Component for refined aesthetic
function NeoDice({ value, isRolling, onClick, disabled }) {
  const getBackgroundColor = () => {
    if (disabled) return 'var(--color-bg-tertiary)';
    if (isRolling) return 'var(--salmon-pink)';
    return 'var(--color-bg-primary)';
  };
  
  const getShadowColor = () => {
    if (isRolling) return 'var(--ultra-violet)';
    return 'var(--moonstone)';
  };
  
  return (
    <div 
      className={`neo-card neo-items-center neo-justify-center ${!disabled ? 'cursor-pointer neo-shake' : 'opacity-50'}`}
      onClick={!disabled ? onClick : undefined}
      style={{
        width: '140px',
        height: '120px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: getBackgroundColor(),
        borderWidth: '4px',
        borderColor: 'var(--color-border)',
        boxShadow: `var(--shadow-offset-x) var(--shadow-offset-y) 0px ${getShadowColor()}`,
        fontSize: value ? '48px' : '32px',
        fontFamily: 'var(--font-heading)',
        fontWeight: '900',
        textTransform: 'uppercase',
        letterSpacing: value ? '0.1em' : '0.05em',
        color: disabled ? 'var(--color-text-muted)' : 'var(--color-text-primary)',
        transition: 'all 0.3s ease',
        padding: '8px'
      }}
    >
      {isRolling ? '🎲' : (value ? value : 'ROLL')}
    </div>
  );
}

// Random.org API Integration
const RANDOM_ORG_BASE = 'https://www.random.org';
const RANDOM_ORG_TIMEOUT = 3000; // 3 second timeout
const RANDOM_ORG_MIN_QUOTA = 100; // Minimum bits required for safe operation
let lastQuotaCheck = 0;
let cachedQuota = null;
const QUOTA_CACHE_DURATION = 60000; // Cache quota for 1 minute

// Check Random.org quota with caching and management
async function checkRandomOrgQuota() {
  try {
    const now = Date.now();
    
    // Use cached quota if recent
    if (cachedQuota !== null && (now - lastQuotaCheck) < QUOTA_CACHE_DURATION) {
      return cachedQuota >= RANDOM_ORG_MIN_QUOTA;
    }
    
    const response = await fetch(`${RANDOM_ORG_BASE}/quota/?format=plain`, {
      method: 'GET',
      signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
    });
    
    if (response.ok) {
      const quota = parseInt(await response.text());
      // Cache the quota result
      cachedQuota = quota;
      lastQuotaCheck = now;
      
      // Log quota status for monitoring
      if (quota < RANDOM_ORG_MIN_QUOTA) {
        console.log(`Random.org quota low: ${quota} bits remaining`);
      }
      
      return quota >= RANDOM_ORG_MIN_QUOTA;
    }
    return false;
  } catch (error) {
    console.warn('Random.org quota check failed:', error);
    // If quota check fails, allow the request to proceed
    // The actual API call will fail if quota is exhausted
    return true;
  }
}

// Fetch true random number from Random.org with enhanced error handling
async function fetchTrueRandomDice() {
  try {
    // Check quota first
    const hasQuota = await checkRandomOrgQuota();
    if (!hasQuota) {
      console.log('Random.org quota insufficient, using fallback');
      return null;
    }

    // Generate random dice roll (1-6)
    const response = await fetch(
      `${RANDOM_ORG_BASE}/integers/?num=1&min=1&max=6&col=1&base=10&format=plain&rnd=new`,
      {
        method: 'GET',
        signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
      }
    );

    if (response.ok) {
      const text = await response.text();
      const result = parseInt(text.trim());
      
      if (!isNaN(result) && result >= 1 && result <= 6) {
        console.log('Random.org dice roll:', result);
        return result;
      } else {
        console.warn('Random.org returned invalid value:', text);
        return null;
      }
    } else if (response.status === 503) {
      console.warn('Random.org service temporarily unavailable');
      return null;
    } else if (response.status === 402) {
      console.warn('Random.org quota exceeded');
      // Reset cached quota
      cachedQuota = 0;
      lastQuotaCheck = Date.now();
      return null;
    }
    
    console.warn('Random.org returned status:', response.status);
    return null;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn('Random.org request timed out');
    } else {
      console.warn('Random.org request failed:', error.message);
    }
    return null;
  }
}

// Fallback to local random generation
function generateLocalRandom() {
  return Math.floor(Math.random() * 6) + 1;
}

// Main random dice function with true random + fallback
async function generateRandomDice() {
  const trueRandom = await fetchTrueRandomDice();
  return trueRandom !== null ? trueRandom : generateLocalRandom();
}

// Fetch master seed for LLM generation (large integer)
async function fetchMasterSeed() {
  try {
    const hasQuota = await checkRandomOrgQuota();
    if (!hasQuota) {
      console.log('Using local master seed generation');
      return Math.floor(Math.random() * 2147483647);
    }
    
    const response = await fetch(
      `${RANDOM_ORG_BASE}/integers/?num=1&min=0&max=2147483647&col=1&base=10&format=plain&rnd=new`,
      {
        method: 'GET',
        signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
      }
    );
    
    if (response.ok) {
      const text = await response.text();
      const seed = parseInt(text.trim());
      console.log('Master seed from Random.org:', seed);
      return seed;
    }
  } catch (error) {
    console.warn('Failed to fetch master seed:', error);
  }
  
  // Fallback to local generation
  return Math.floor(Math.random() * 2147483647);
}

// Fetch temperature base (0.0-1.0 decimal)
async function fetchTemperatureBase() {
  try {
    const hasQuota = await checkRandomOrgQuota();
    if (!hasQuota) {
      return Math.random();
    }
    
    const response = await fetch(
      `${RANDOM_ORG_BASE}/decimal-fractions/?num=1&dec=2&col=1&format=plain&rnd=new`,
      {
        method: 'GET',
        signal: AbortSignal.timeout(RANDOM_ORG_TIMEOUT)
      }
    );
    
    if (response.ok) {
      const text = await response.text();
      const temp = parseFloat(text.trim());
      console.log('Temperature base from Random.org:', temp);
      return temp;
    }
  } catch (error) {
    console.warn('Failed to fetch temperature base:', error);
  }
  
  // Fallback to local generation
  return Math.random();
}

// Calculate step-specific temperature based on base value
function getStepTemperature(stepId, temperatureBase) {
  const ranges = {
    'neogenre': [0.9, 1.2],   // Most creative - needs novel combinations
    'theme': [0.9, 1.2],      // Most creative
    'symbol': [0.8, 1.1],     // Creative  
    'mechanic': [0.7, 0.9],   // Balanced
    'form': [0.6, 0.8],       // Structured
    'color': [0.8, 1.0],      // Descriptive
    'harmony': [0.7, 0.9],    // Technical
    'production': [0.7, 0.9]  // Technical
  };
  
  const [min, max] = ranges[stepId] || [0.8, 1.0];
  return min + (temperatureBase * (max - min));
}

export default function App() {
  const { database, useLiveQuery } = useFireproof("finitude-enhanced")
  const [currentStepIndex, setCurrentStepIndex] = useState(0)
  const [options, setOptions] = useState([])
  const [loading, setLoading] = useState(false)
  const [rolling, setRolling] = useState(false)
  const [diceValue, setDiceValue] = useState(null)
  const [selectedIndex, setSelectedIndex] = useState(null)
  const [vetoUsed, setVetoUsed] = useState(false)
  const [selections, setSelections] = useState({})
  const [rollHistory, setRollHistory] = useState([])
  const [sessionSeed, setSessionSeed] = useState(Math.floor(Math.random() * 2147483647))
  const [sessionTimestamp, setSessionTimestamp] = useState(new Date().toISOString())
  const [showResults, setShowResults] = useState(false)
  const [focusingIntention, setFocusingIntention] = useState(false)
  const [intentionCountdown, setIntentionCountdown] = useState(3)
  const [sessionStarted, setSessionStarted] = useState(false)
  const [initialIntention, setInitialIntention] = useState(false)
  const [masterSeed, setMasterSeed] = useState(null)
  const [temperatureBase, setTemperatureBase] = useState(null)
  const [selectedConstraints, setSelectedConstraints] = useState(null)
  const [viewingSessionId, setViewingSessionId] = useState(null)
  const [openAccordionItems, setOpenAccordionItems] = useState({})
  const animationRef = useRef()
  const intentionTimerRef = useRef()
  const initialIntentionTimerRef = useRef()
  
  const allSteps = [
    {
      id: 'neogenre',
      name: 'Neo-Genre',
      description: 'Invent a genre that doesn\'t exist yet',
      prompt: `IMPORTANT: Return ONLY prefix words, NOT full genre descriptions!

Generate exactly 6 single-word PREFIXES for new music genres.

Each word should be:
- A single word (3-10 letters)
- Evocative and atmospheric
- NOT a common genre prefix (avoid: hyper, cyber, post, neo, dark, etc.)

Good examples: glass, silk, ember, frost, mirror, velvet, smoke, prism

CRITICAL: Return ONLY a JSON object with a "prefixes" array containing 6 strings.
Do NOT include "items" or "label" or "explainer" fields.

Correct format:
{"prefixes": ["word1", "word2", "word3", "word4", "word5", "word6"]}

WRONG format (do not use):
{"items": [...]}`,
      suffixes: ['-core', '-grind', '-crust', '-violence', '-slam', '-step', '-wave', '-house', '-trance', '-beat', '-tek', '-bass', '-scape', '-drone', '-gaze', '-cloud', '-chill', '-punk', '-tronica', '-pop', '-hop', '-fusion', '-mix', '-cross', '-hybrid', '-matic', '-noize', '-clash', '-void', '-chaos', '-ritual']
    },
    { 
      id: 'theme', 
      name: 'Theme', 
      description: 'Core emotional territory',
      prompt: 'Generate brief, poetic themes. Maximum 4-5 words. Create evocative fragments that suggest emotional worlds through minimal language. Think haiku-like brevity with symbolic weight. Examples for tone only (do NOT use these): "letters to no one", "museum of almost", "gravity of small betrayals", "dialects of longing". Keep them short, impressionistic, and open to interpretation. No long phrases or wordy descriptions. Create entirely NEW themes.'
    },
    { 
      id: 'symbol', 
      name: 'Symbol Pair', 
      description: 'Two resonant images',
      prompt: 'Create pairs of brief, evocative symbols joined by " + ". Use simple, broadly referential words that carry poetic weight without being precious. Keep each word short and airy. Avoid overly dramatic or flowery choices - aim for quiet resonance. NOTE: These examples are for style reference ONLY - do NOT use these specific pairs: "Moths + Static", "Fever + Maps". Create entirely NEW symbol combinations.'
    },
    { 
      id: 'mechanic', 
      name: 'Mechanic', 
      description: 'Musical DNA to borrow',
      prompt: 'Name concrete music mechanics to borrow (rhythm patterns with BPM ranges, bass approaches, harmony concepts, voice techniques, texture ideas, or form structures). Be specific and practical. NOTE: Generate ORIGINAL mechanics - do not simply repeat common examples like "trap hi-hats" or "walking bassline". Create fresh, specific musical ideas.'
    },
    { 
      id: 'form', 
      name: 'Form', 
      description: 'Song structure',
      prompt: 'Provide compact, readable song forms using standard notation (V=verse, C=chorus, B=bridge, etc). Keep notation clear and musical. NOTE: The examples "V/C×3 + Bridge", "AABA" are for format reference only - generate UNIQUE form structures, not these specific ones.'
    },
    { 
      id: 'color', 
      name: 'Color Mood', 
      description: 'Emotional palette',
      prompt: 'Generate color moods with context and hue that evoke specific emotional territories. Combine a descriptive context with a color. NOTE: Do NOT use obvious examples like "hospital green" or "midnight blue" - create ORIGINAL, unexpected color-context combinations that suggest unique moods.'
    },
    { 
      id: 'harmony', 
      name: 'Harmony', 
      description: 'Chord approach',
      prompt: 'Suggest compact chord progressions or harmonic approaches. Include specific chords or modal colors. Keep it readable for musicians. NOTE: Create ORIGINAL progressions - avoid clichés like I-V-vi-IV. Generate fresh harmonic ideas that musicians can actually play.'
    },
    { 
      id: 'production', 
      name: 'Production Move', 
      description: 'Signature production technique',
      prompt: 'Describe a single, stageable production move. Be specific about when and how to apply the effect. NOTE: These are format examples only - do NOT suggest "tape-stop" or "filter sweep". Create ORIGINAL, specific production techniques that can be realistically implemented.'
    }
  ]

  // Filter steps based on selected constraints
  const steps = selectedConstraints 
    ? allSteps.filter(step => selectedConstraints[step.id])
    : allSteps

  const currentStep = steps[currentStepIndex]
  
  // Cleanup timers on unmount
  React.useEffect(() => {
    return () => {
      if (animationRef.current) clearTimeout(animationRef.current)
      if (intentionTimerRef.current) clearInterval(intentionTimerRef.current)
      if (initialIntentionTimerRef.current) clearInterval(initialIntentionTimerRef.current)
    }
  }, [])
  
  // Handle initial intention completion
  const handleIntentionComplete = (seed, temp, constraints) => {
    setMasterSeed(seed);
    setTemperatureBase(temp);
    setSelectedConstraints(constraints);
    setSessionStarted(true);
    console.log('Session initialized with seed:', seed, 'temperature base:', temp, 'constraints:', constraints);
  }
  
  const getFallbackOptions = (stepId) => {
    const fallbacks = {
      neogenre: [
        { label: "velvetcore", explainer: "" },
        { label: "glassstep", explainer: "" },
        { label: "smokegaze", explainer: "" },
        { label: "prismwave", explainer: "" },
        { label: "dustpunk", explainer: "" },
        { label: "mirrorhouse", explainer: "" }
      ],
      theme: [
        { label: "archaeology of silence", explainer: "Excavating unspoken histories" },
        { label: "small betrayals", explainer: "Minor treacheries accumulating" },
        { label: "past selves", explainer: "Dialogues across time" },
        { label: "museum of almost", explainer: "Archive of near-misses" },
        { label: "maps in water", explainer: "Dissolving boundaries" },
        { label: "dialects of longing", explainer: "Languages of absence" }
      ],
      symbol: [
        { label: "Moths + Static", explainer: "Attraction to interference, drawn to noise" },
        { label: "Fever + Maps", explainer: "Delirium and navigation, lost while searching" },
        { label: "Bridges + Ash", explainer: "Connection and aftermath, what remains of crossing" },
        { label: "Windows + Tide", explainer: "Observation and rhythm, watching cycles" },
        { label: "Keys + Smoke", explainer: "Access and dissolution, opening into vapor" },
        { label: "Mirrors + Rain", explainer: "Reflection and obscurity, seeing through weather" }
      ],
      mechanic: [
        { label: "Trap hi-hats at 140 BPM", explainer: "Rolling hi-hat patterns with occasional triplets" },
        { label: "Walking bassline", explainer: "Quarter note bass movement, jazz-influenced" },
        { label: "Call and response vocals", explainer: "Lead line answered by harmony or doubled voice" },
        { label: "Polyrhythm 3:4", explainer: "Three against four rhythm creates tension" },
        { label: "Drop tuning riffs", explainer: "Heavy, low guitar tuning for weight" },
        { label: "Whisper to belt dynamics", explainer: "Extreme vocal dynamic range for impact" }
      ],
      form: [
        { label: "ABABCB", explainer: "Verse/Chorus alternating with a bridge before final chorus" },
        { label: "Through-composed", explainer: "No repeating sections, continuous development" },
        { label: "V/V/C/V/C/C", explainer: "Classic pop structure with double chorus ending" },
        { label: "AABA", explainer: "32-bar standard with contrasting bridge" },
        { label: "Rondo ABACA", explainer: "Main theme returns between new sections" },
        { label: "V/PC/C pattern", explainer: "Verse, pre-chorus, chorus cycle" }
      ],
      color: [
        { label: "Fluorescent white", explainer: "Harsh overhead lighting, office anxiety" },
        { label: "Dawn purple", explainer: "The hope and exhaustion of staying up all night" },
        { label: "Rust orange", explainer: "Decay, autumn, industrial decline" },
        { label: "Ocean gray", explainer: "Vast, neutral, contemplative depth" },
        { label: "Neon pink", explainer: "Artificial vibrancy, night life energy" },
        { label: "Forest green", explainer: "Deep natural sanctuary, growth" }
      ],
      harmony: [
        { label: "i - VI - III - VII", explainer: "Dark modal progression, Dorian-influenced" },
        { label: "I - V - vi - IV", explainer: "Pop progression with emotional resolution" },
        { label: "Pedal tone under moving chords", explainer: "Static bass note creates tension" },
        { label: "ii - V - I jazz cadence", explainer: "Smooth resolution with sophistication" },
        { label: "Chromatic descent", explainer: "Bassline walks down by half steps" },
        { label: "Quartal harmony", explainer: "Chords built in fourths, modern sound" }
      ],
      production: [
        { label: "Reverse reverb on first word", explainer: "Swoosh into each verse for dramatic entry" },
        { label: "Side-chain compression on chorus", explainer: "Everything pumps with the kick drum" },
        { label: "Telephone filter on bridge", explainer: "Lo-fi intimate moment before final chorus" },
        { label: "Vocal chop rhythms", explainer: "Stuttered vocal samples as percussion" },
        { label: "Tape saturation warmth", explainer: "Analog warmth on all tracks" },
        { label: "Hard pan call/response", explainer: "Voices jump left to right in conversation" }
      ]
    }
    
    return fallbacks[stepId] || Array(6).fill(null).map((_, i) => ({
      label: `Option ${i + 1}`,
      explainer: "A creative constraint for your song"
    }))
  }

  useEffect(() => {
    if (currentStepIndex < steps.length && !showResults && sessionStarted) {
      loadStepOptions()
    }
  }, [currentStepIndex, sessionStarted])

  const loadStepOptions = async (retryCount = 0) => {
    if (retryCount === 0) {
      setLoading(true)
      setOptions([])
      setSelectedIndex(null)
      setDiceValue(null)
    }
    
    const step = steps[currentStepIndex]
    
    // Calculate temperature and seed for this step
    // Add slight variation on retry to get different results
    const tempVariation = retryCount * 0.1;
    const baseTemp = temperatureBase ? getStepTemperature(step.id, temperatureBase) : 0.9;
    const temperature = Math.min(1.5, baseTemp + tempVariation);
    const stepSeed = masterSeed ? (masterSeed + currentStepIndex + (retryCount * 100)) % 2147483647 : undefined;
    
    console.log(`Generating ${step.id} with temperature: ${temperature}, seed: ${stepSeed}, retry: ${retryCount}`);
    
    try {
      console.log(`🎲 Calling AI for ${step.id}...`);
      console.log('API Key available:', !!window.CALLAI_API_KEY);
      
      // Different prompts and schemas for neo-genre vs other steps
      let prompt, schema;
      
      if (step.id === 'neogenre') {
        // Neo-genre needs a special format - just prefixes
        prompt = step.prompt; // Use the prompt as-is, it already has the right format
        schema = {
          properties: {
            prefixes: {
              type: "array",
              minItems: 6,
              maxItems: 6,
              items: { type: "string", minLength: 3, maxLength: 10 }
            }
          },
          required: ["prefixes"]
        };
      } else {
        // Regular constraints need items with labels and explainers
        prompt = `${step.prompt} 
        
IMPORTANT: You MUST generate exactly 6 unique options. 
Return as JSON array with this exact structure:
{
  "items": [
    {"label": "option 1", "explainer": "description under 150 chars"},
    {"label": "option 2", "explainer": "description under 150 chars"},
    {"label": "option 3", "explainer": "description under 150 chars"},
    {"label": "option 4", "explainer": "description under 150 chars"},
    {"label": "option 5", "explainer": "description under 150 chars"},
    {"label": "option 6", "explainer": "description under 150 chars"}
  ]
}`;
        schema = {
          properties: {
            items: {
              type: "array",
              minItems: 6,
              maxItems: 6,
              items: {
                type: "object",
                required: ["label", "explainer"],
                properties: {
                  label: { type: "string", minLength: 1 },
                  explainer: { type: "string", minLength: 1, maxLength: 150 }
                }
              }
            }
          },
          required: ["items"]
        };
      }
      
      const response = await callAI(prompt, {
        schema: schema,
        temperature: temperature,
        seed: stepSeed,
        // Explicitly pass API configuration
        apiKey: window.CALLAI_API_KEY || 'sk-vibes-proxy-managed',
        model: 'openrouter/auto',
        max_tokens: 1000
      })
      
      console.log(`✅ AI Response received for ${step.id}:`, response);
      
      // Handle different response formats
      let data;
      let items = [];
      
      try {
        // Try to parse as JSON
        data = typeof response === 'string' ? JSON.parse(response) : response;
        
        // Special handling for neo-genre
        if (step.id === 'neogenre') {
          if (data.prefixes && Array.isArray(data.prefixes)) {
            // Combine prefixes with random suffixes
            items = data.prefixes.slice(0, 6).map(prefix => {
              const randomSuffix = step.suffixes[Math.floor(Math.random() * step.suffixes.length)];
              const genreName = prefix.toLowerCase() + randomSuffix;
              return {
                label: genreName,
                explainer: '' // No explainer needed for neo-genre
              };
            });
          } else {
            console.warn('Neo-genre response missing prefixes:', data);
            items = [];
          }
        } else {
          // Handle different possible response structures for other steps
          if (Array.isArray(data)) {
            items = data.slice(0, 6);
          } else if (data.items && Array.isArray(data.items)) {
            items = data.items.slice(0, 6);
          } else if (data.options && Array.isArray(data.options)) {
            items = data.options.slice(0, 6);
          } else if (data.label && data.explainer) {
            // Single item response, wrap in array
            items = [data];
          } else {
            console.warn('Unexpected response structure:', data);
            items = [];
          }
        }
      } catch (parseError) {
        console.error('Failed to parse AI response:', parseError);
        console.log('Raw response:', response);
        items = [];
      }
      
      console.log(`📊 Generated ${items.length} items for ${step.id}`);
      
      // Check if we got enough valid items
      const validItems = items.filter(item => item && item.label && item.explainer);
      
      if (validItems.length < 6 && retryCount < 2) {
        console.warn(`⚠️ Only got ${validItems.length} valid items, retrying... (attempt ${retryCount + 2}/3)`);
        return loadStepOptions(retryCount + 1);
      }
      
      // Pad with fallbacks if absolutely necessary
      if (validItems.length < 6) {
        console.warn(`⚠️ After ${retryCount + 1} attempts, only got ${validItems.length} items for ${step.id}, padding with fallbacks`);
        const fallbacks = getFallbackOptions(step.id)
        while (validItems.length < 6) {
          validItems.push(fallbacks[validItems.length])
        }
      }
      
      setOptions(validItems)
      setLoading(false)
    } catch (error) {
      console.error(`❌ Error loading options for ${step.id} (attempt ${retryCount + 1}/3):`, error)
      console.error('Full error details:', error.stack || error)
      
      // Retry with different parameters
      if (retryCount < 2) {
        console.log(`🔄 Retrying AI call for ${step.id}...`);
        return loadStepOptions(retryCount + 1);
      }
      
      // Final fallback after all retries failed
      console.log('🔄 All retries failed, using fallback options for', step.id)
      setOptions(getFallbackOptions(step.id))
      setLoading(false)
    }
  }

  const rollDice = async () => {
    if (rolling || focusingIntention || !options.length || selectedIndex !== null) return
    
    // Start intention focusing phase
    setFocusingIntention(true)
    setIntentionCountdown(3)
    
    // Countdown timer
    let countdown = 3
    intentionTimerRef.current = setInterval(() => {
      countdown--
      setIntentionCountdown(countdown)
      
      if (countdown <= 0) {
        clearInterval(intentionTimerRef.current)
        performRoll()
      }
    }, 1000)
  }
  
  const performRoll = async () => {
    setFocusingIntention(false)
    setRolling(true)
    
    // Get true random number from Random.org or fallback
    const roll = await generateRandomDice()
    const index = roll - 1
    
    let animationCount = 0
    const animateRoll = () => {
      animationCount++
      setDiceValue(Math.floor(Math.random() * 6) + 1)
      
      if (animationCount < 10) {
        animationRef.current = setTimeout(animateRoll, 70)
      } else {
        setDiceValue(roll)
        setSelectedIndex(index)
        setRolling(false)
        
        const newSelections = {
          ...selections,
          [currentStep.id]: options[index]
        }
        setSelections(newSelections)
        
        const newHistory = [...rollHistory, { step: currentStep.id, roll, index }]
        setRollHistory(newHistory)
      }
    }
    
    animateRoll()
  }

  const useVeto = async (retryCount = 0) => {
    if (vetoUsed || selectedIndex === null) return
    if (retryCount === 0) {
      setVetoUsed(true)
      setLoading(true)
    }
    
    const vetoedOption = options[selectedIndex]
    const step = steps[currentStepIndex]
    
    // Use same temperature but different seed for veto, with variation on retry
    const tempVariation = retryCount * 0.15;
    const baseTemp = temperatureBase ? getStepTemperature(step.id, temperatureBase) : 0.9;
    const temperature = Math.min(1.5, baseTemp + tempVariation + 0.1); // Slightly higher temp for veto
    const vetoSeed = masterSeed ? (masterSeed + currentStepIndex + 1000 + (retryCount * 100)) % 2147483647 : undefined;
    
    try {
      console.log(`🔄 Generating veto replacement for ${step.id}, attempt ${retryCount + 1}`);
      
      // Different prompts and schemas for neo-genre vs other steps
      let prompt, schema;
      
      if (step.id === 'neogenre') {
        // For neo-genre veto, we need a single new prefix
        const vetoedPrefix = vetoedOption.label.replace(/-(core|grind|crust|violence|slam|step|wave|house|trance|beat|tek|bass|scape|drone|gaze|cloud|chill|punk|tronica|pop|hop|fusion|mix|cross|hybrid|matic|noize|clash|void|chaos|ritual)$/, '');
        prompt = `Generate exactly 1 NEW unique PREFIX word for creating a new music genre.
        
The word must be DIFFERENT from: "${vetoedPrefix}"

REQUIREMENTS:
- Single evocative word (3-10 letters)
- Focus on: materials, natural phenomena, emotions, textures, abstract concepts
- AVOID common genre prefixes and the word "${vetoedPrefix}"
- Think poetic, unexpected, sensory

Return as JSON:
{
  "prefixes": ["newword"]
}`;
        schema = {
          properties: {
            prefixes: {
              type: "array",
              minItems: 1,
              maxItems: 1,
              items: { type: "string", minLength: 3, maxLength: 10 }
            }
          },
          required: ["prefixes"]
        };
      } else {
        // Regular constraint veto
        prompt = `${step.prompt} 
        
Generate exactly 1 NEW unique option that is DIFFERENT from: "${vetoedOption.label}". 
The new option must be creative and distinct.
Return as JSON with this exact structure:
{
  "label": "new unique option",
  "explainer": "description under 150 chars"
}`;
        schema = {
          type: "object",
          required: ["label", "explainer"],
          properties: {
            label: { type: "string", minLength: 1 },
            explainer: { type: "string", minLength: 1, maxLength: 150 }
          }
        };
      }
      
      const response = await callAI(prompt, {
        schema: schema,
        temperature: temperature,
        seed: vetoSeed,
        apiKey: window.CALLAI_API_KEY || 'sk-vibes-proxy-managed',
        model: 'openrouter/auto',
        max_tokens: 500
      })
      
      let newOption;
      try {
        const data = typeof response === 'string' ? JSON.parse(response) : response;
        
        // Special handling for neo-genre veto
        if (step.id === 'neogenre') {
          if (data.prefixes && Array.isArray(data.prefixes) && data.prefixes.length > 0) {
            const prefix = data.prefixes[0];
            const randomSuffix = step.suffixes[Math.floor(Math.random() * step.suffixes.length)];
            newOption = {
              label: prefix.toLowerCase() + randomSuffix,
              explainer: '' // No explainer needed for neo-genre
            };
          } else {
            throw new Error('Invalid neo-genre response structure');
          }
        } else {
          newOption = data;
        }
      } catch (parseError) {
        console.error('Failed to parse veto response:', parseError);
        throw new Error('Invalid response format');
      }
      
      // Validate the new option
      if (!newOption.label || !newOption.explainer) {
        throw new Error('Invalid option structure');
      }
      
      const newOptions = [...options]
      newOptions[selectedIndex] = newOption
      setOptions(newOptions)
      setLoading(false)
    } catch (error) {
      console.error(`Error generating veto replacement (attempt ${retryCount + 1}):`, error)
      
      // Retry with different parameters
      if (retryCount < 2) {
        console.log('Retrying veto generation...');
        return useVeto(retryCount + 1);
      }
      
      // Final fallback after retries
      console.log('Using fallback for veto');
      const fallbacks = getFallbackOptions(step.id)
      const newOptions = [...options]
      // Pick a different fallback option
      const fallbackIndex = (selectedIndex + 3 + retryCount) % fallbacks.length;
      newOptions[selectedIndex] = fallbacks[fallbackIndex]
      setOptions(newOptions)
      setLoading(false)
    }
    
    // Reset selection state after veto is processed
    setSelectedIndex(null)
    setDiceValue(null)
    
    const newSelections = { ...selections }
    delete newSelections[currentStep.id]
    setSelections(newSelections)
    setRollHistory(rollHistory.filter(h => h.step !== currentStep.id))
  }

  const proceedToNext = async () => {
    if (selectedIndex === null) return
    
    if (currentStepIndex === steps.length - 1) {
      await saveSession()
      setShowResults(true)
    } else {
      setCurrentStepIndex(currentStepIndex + 1)
    }
  }

  const saveSession = async () => {
    await database.put({
      type: 'finitude-session',
      seed: sessionSeed,
      timestamp: sessionTimestamp,
      selections: selections,
      rollHistory: rollHistory,
      selectedConstraints: selectedConstraints,
      completedAt: new Date().toISOString()
    })
  }

  const generateMarkdown = () => {
    let markdown = `# Finitude Session ${sessionSeed}\n${new Date(sessionTimestamp).toLocaleString()}\n\n`
    
    steps.forEach(step => {
      const item = selections[step.id]
      if (item) {
        if (step.id === 'neogenre') {
          markdown += `## ${step.name}\n**${item.label}**\n\n`
        } else {
          markdown += `## ${step.name}\n**${item.label}**\n_${item.explainer}_\n\n`
        }
      }
    })
    
    markdown += `---\n_Generated by Finitude_`
    return markdown
  }

  const copyMarkdown = () => {
    navigator.clipboard.writeText(generateMarkdown())
  }

  const { docs: savedSessions } = useLiveQuery("type", { key: "finitude-session", limit: 10, descending: true })
  
  // Generate a meaningful name from blueprint content
  const generateBlueprintName = (session) => {
    if (!session.selections) return `Session #${session.seed}`;
    
    // Try to create a name from theme and symbol pair
    const theme = session.selections.theme?.label || '';
    const symbol = session.selections.symbol?.label || '';
    
    if (theme && symbol) {
      // Extract key words from theme (first few words)
      const themeWords = theme.split(' ').slice(0, 3).join(' ');
      // Symbol pair is usually formatted as "X + Y"
      const symbolFirst = symbol.split('+')[0]?.trim();
      
      if (symbolFirst) {
        return `${themeWords} / ${symbolFirst}`;
      }
      return themeWords;
    }
    
    // Fallback to other elements
    const color = session.selections.color?.label;
    if (color) return `${color} Session`;
    
    return `Session #${session.seed}`;
  }
  
  // View a saved session
  const viewSavedSession = (sessionId) => {
    const session = savedSessions.find(s => s._id === sessionId);
    if (session) {
      setViewingSessionId(sessionId);
      setShowResults(true);
      setSelections(session.selections || {});
      setRollHistory(session.rollHistory || []);
      setSessionSeed(session.seed);
      setSessionTimestamp(session.timestamp);
      setSelectedConstraints(session.selectedConstraints || {});
      setSessionStarted(false);
      setInitialIntention(false);
    }
  }
  
  // Toggle accordion item
  const toggleAccordionItem = (itemId) => {
    setOpenAccordionItems(prev => ({
      ...prev,
      [itemId]: !prev[itemId]
    }));
  }

  if (showResults) {
    return (
      <NeoContainer>
        <div style={{
          paddingTop: 'var(--space-md)',
          display: 'flex',
          justifyContent: 'center'
        }}>
          <img 
            src="banner.png" 
            alt="Finitude Banner" 
            style={{
              maxWidth: '600px',
              height: 'auto'
            }}
          />
        </div>
        
        <NeoCard className="neo-mt-lg">
          <NeoCardHeader>
            <div className="neo-flex neo-justify-between neo-items-center">
              <NeoHeading level="xl">🎵 SONG BLUEPRINT</NeoHeading>
              <div>
                <NeoBadge variant="primary">#{sessionSeed}</NeoBadge>
                <div style={{ fontSize: '12px', marginTop: '4px', color: 'var(--color-text-muted)' }}>
                  {new Date(sessionTimestamp).toLocaleString()}
                </div>
              </div>
            </div>
          </NeoCardHeader>
          
          <NeoCardContent>
            <div className="neo-flex neo-flex-wrap neo-mb-lg" style={{ gap: 'var(--space-xs)' }}>
              {rollHistory.map((h, i) => (
                <div key={i} className="relative">
                  <NeoBadge 
                    variant="accent" 
                    style={{ 
                      fontSize: '18px', 
                      width: '40px', 
                      height: '40px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    {h.roll}
                  </NeoBadge>
                </div>
              ))}
            </div>

            <div className="neo-grid neo-grid-cols-1" style={{ gap: 'var(--space-lg)' }}>
              {steps.filter(s => !selectedConstraints || selectedConstraints[s.id]).map(step => {
                const item = selections[step.id]
                if (!item) return null
                
                return (
                  <NeoCard key={step.id} style={{ 
                    borderLeft: '8px solid var(--color-primary)',
                    backgroundColor: 'var(--color-bg-tertiary)'
                  }}>
                    <NeoCardHeader style={{ marginBottom: 'var(--space-sm)' }}>
                      <NeoHeading level="sm">{step.name}</NeoHeading>
                    </NeoCardHeader>
                    <NeoCardContent>
                      <div style={{ 
                        fontSize: '20px', 
                        fontFamily: 'var(--font-heading)',
                        fontWeight: '900',
                        marginBottom: 'var(--space-sm)',
                        textTransform: 'uppercase'
                      }}>
                        {item.label}
                      </div>
                      {step.id !== 'neogenre' && (
                        <div style={{ 
                          fontSize: '14px',
                          color: 'var(--color-text-muted)',
                          fontStyle: 'italic'
                        }}>
                          {item.explainer}
                        </div>
                      )}
                    </NeoCardContent>
                  </NeoCard>
                )
              })}
            </div>
          </NeoCardContent>

          <NeoCardFooter>
            <NeoButton onClick={copyMarkdown} variant="accent" size="lg">
              📋 COPY TEXT
            </NeoButton>
            <NeoButton onClick={() => window.print()} variant="neutral" size="lg">
              🖨️ PRINT
            </NeoButton>
            <NeoButton onClick={() => window.location.reload()} variant="danger" size="lg">
              🔄 NEW SESSION
            </NeoButton>
          </NeoCardFooter>
        </NeoCard>
      </NeoContainer>
    )
  }

  // Show initial intention screen if session hasn't started
  if (!sessionStarted) {
    return <InitialIntention onComplete={handleIntentionComplete} />;
  }
  
  return (
    <NeoContainer>
      {/* Banner at top of page */}
      <div style={{ 
        textAlign: 'center', 
        marginBottom: 'var(--space-xl)',
        paddingTop: 'var(--space-md)',
        display: 'flex',
        justifyContent: 'center'
      }}>
        <img 
          src="banner.png" 
          alt="Finitude Banner" 
          style={{
            maxWidth: '600px',
            height: 'auto'
          }}
        />
      </div>
      
      <NeoCard>
        
        <NeoCardContent>
          {/* Veto Button */}
          <div className="neo-flex neo-justify-between neo-items-center neo-mb-lg">
            <NeoBadge variant="neutral">
              Step {currentStepIndex + 1} of {steps.length}
            </NeoBadge>
            <div className="neo-flex">
              {!vetoUsed && selectedIndex !== null && !loading && (
                <NeoButton onClick={useVeto} variant="warning" size="sm">
                  🔄 VETO & REPLACE
                </NeoButton>
              )}
              {vetoUsed && (
                <NeoBadge variant="neutral">VETO USED</NeoBadge>
              )}
            </div>
          </div>

          {/* Progress Bar */}
          <div className="neo-mb-xl">
            <NeoProgress 
              value={((currentStepIndex + 1) / steps.length) * 100}
              className="neo-mb-sm"
            />
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              fontSize: '12px', 
              color: 'var(--color-text-muted)',
              fontFamily: 'var(--font-heading)',
              fontWeight: '900',
              textTransform: 'uppercase'
            }}>
              <span>Step {currentStepIndex + 1}</span>
              <span>{steps.length} Total</span>
            </div>
          </div>

          {/* Current Step Header */}
          <div style={{ textAlign: 'center', marginBottom: 'var(--space-xl)' }}>
            <NeoHeading level="lg">{currentStep.name}</NeoHeading>
            <div style={{ 
              color: 'var(--color-text-muted)', 
              fontStyle: 'italic',
              fontSize: '16px'
            }}>
              {currentStep.description}
            </div>
          </div>

          {/* Dice Interface / Next Button Area */}
          <div className="neo-flex neo-justify-center neo-mb-xl">
            {selectedIndex !== null && !loading ? (
              // Show Next Button when selection is made
              <NeoButton 
                onClick={proceedToNext}
                variant="success"
                size="lg"
                style={{ fontSize: '20px', padding: '0 var(--space-xl)' }}
              >
                {currentStepIndex === steps.length - 1 ? '✨ VIEW BLUEPRINT' : 'NEXT STEP →'}
              </NeoButton>
            ) : focusingIntention ? (
              // Show intention focus animation
              <IntentionFocus 
                countdown={intentionCountdown}
                onComplete={() => {/* handled in rollDice */}}
              />
            ) : (
              // Show Dice when no selection or loading
              <NeoDice 
                value={diceValue}
                isRolling={rolling}
                onClick={rollDice}
                disabled={selectedIndex !== null || loading || focusingIntention}
              />
            )}
          </div>

          {/* Loading State */}
          {loading && (
            <div style={{ textAlign: 'center', padding: 'var(--space-xl)' }}>
              <NeoAlert variant="warning" title="Loading constraints">
                One moment please.
              </NeoAlert>
            </div>
          )}

          {/* Options Grid */}
          {options.length > 0 && !loading && (
            <div className="neo-grid neo-grid-cols-1 neo-mb-lg">
              {options.map((option, i) => {
                const getCardColors = () => {
                  if (selectedIndex === i) {
                    return {
                      bg: 'var(--salmon-pink)',
                      color: 'var(--color-text-inverse)',
                      badgeVariant: 'neutral',
                      shadow: 'var(--shadow-offset-x) var(--shadow-offset-y) 0px var(--ultra-violet)'
                    };
                  }
                  if (selectedIndex !== null) {
                    return {
                      bg: 'var(--color-bg-tertiary)',
                      color: 'var(--color-text-muted)',
                      badgeVariant: 'neutral',
                      shadow: 'var(--shadow-main)'
                    };
                  }
                  
                  // Rotate through refined colors for variety
                  const colors = [
                    { bg: 'var(--lavender-blush)', variant: 'primary' },
                    { bg: 'var(--moonstone)', variant: 'secondary' },
                    { bg: 'var(--color-bg-secondary)', variant: 'accent' },
                    { bg: 'var(--ultra-violet)', variant: 'dark', textColor: 'var(--color-text-inverse)' },
                    { bg: 'var(--salmon-pink)', variant: 'accent', textColor: 'var(--color-text-inverse)' },
                    { bg: 'var(--lavender-blush)', variant: 'pastel' }
                  ];
                  const colorSet = colors[i % colors.length];
                  return {
                    bg: colorSet.bg,
                    color: colorSet.textColor || 'var(--color-text-primary)',
                    badgeVariant: colorSet.variant,
                    shadow: i % 2 === 0 ? 'var(--shadow-main)' : 'var(--shadow-alt)'
                  };
                };
                
                const cardColors = getCardColors();
                
                return (
                  <NeoCard 
                    key={i}
                    style={{
                      backgroundColor: cardColors.bg,
                      opacity: selectedIndex !== null && selectedIndex !== i ? 0.4 : 1,
                      transform: selectedIndex === i ? 'scale(1.02)' : 'scale(1)',
                      transition: 'all 0.3s ease',
                      cursor: selectedIndex === null ? 'pointer' : 'default',
                      color: cardColors.color,
                      boxShadow: cardColors.shadow
                    }}
                    onClick={selectedIndex === null ? () => setSelectedIndex(i) : undefined}
                  >
                    <div className="neo-flex neo-items-center" style={{ gap: 'var(--space-md)' }}>
                      <NeoBadge 
                        variant={cardColors.badgeVariant}
                        style={{ fontSize: '18px', minWidth: '32px', minHeight: '32px' }}
                      >
                        {i + 1}
                      </NeoBadge>
                      <div style={{ flex: 1 }}>
                        <div style={{ 
                          fontFamily: 'var(--font-heading)',
                          fontSize: '18px',
                          fontWeight: '900',
                          marginBottom: 'var(--space-xs)',
                          textTransform: 'uppercase'
                        }}>
                          {option.label}
                        </div>
                        <div style={{ 
                          fontSize: '14px',
                          fontStyle: 'italic',
                          lineHeight: 1.4,
                          opacity: selectedIndex === i ? 0.9 : 0.8
                        }}>
                          {option.explainer}
                        </div>
                      </div>
                    </div>
                  </NeoCard>
                );
              })}
            </div>
          )}

        </NeoCardContent>
      </NeoCard>

      {/* Instructions Card */}
      <NeoCard className="neo-mt-lg">
        <NeoCardHeader>
          <NeoHeading level="md">📖 HOW IT WORKS</NeoHeading>
        </NeoCardHeader>
        <NeoCardContent>
          <div style={{ lineHeight: 1.6, fontSize: '16px' }}>
            <p style={{ marginBottom: 'var(--space-md)' }}>
              <strong>When everything is possible, it's hard to begin.</strong> Modernity is walking us in empty circles. This is one way out. Finitude uses chance and constraint to open new paths for songwriting. Click the dice to reveal one of six options. Each of the seven steps adds a fresh creative boundary—theme, story, imagery, structure, or sound. By the end, you'll have a unique framework to write from.
            </p>
            <p style={{ marginBottom: 'var(--space-md)' }}>
              You get one veto per session to swap out any result, but otherwise the roll stands.
            </p>
            <p style={{ fontStyle: 'italic' }}>
              <strong>Embrace your limits. That's where the songs live.</strong>
            </p>
          </div>
        </NeoCardContent>
      </NeoCard>

      {/* Recent Blueprints */}
      {savedSessions.length > 0 && (
        <NeoCard className="neo-mt-lg">
          <NeoCardHeader>
            <NeoHeading level="md">📚 RECENT BLUEPRINTS</NeoHeading>
          </NeoCardHeader>
          <NeoCardContent>
            <NeoAccordion>
              {savedSessions.slice(0, 5).map(sess => {
                const blueprintName = generateBlueprintName(sess);
                const isOpen = openAccordionItems[sess._id];
                const constraintCount = sess.selectedConstraints ? 
                  Object.values(sess.selectedConstraints).filter(v => v).length : 7;
                
                return (
                  <NeoAccordionItem key={sess._id}>
                    <NeoAccordionTrigger 
                      isOpen={isOpen}
                      onClick={() => toggleAccordionItem(sess._id)}
                    >
                      <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '4px' }}>
                        <span style={{ lineHeight: '1.3' }}>{blueprintName}</span>
                        <span style={{ 
                          fontSize: '12px', 
                          opacity: 0.6,
                          fontWeight: '400',
                          letterSpacing: '0.02em'
                        }}>
                          {new Date(sess.completedAt || sess.timestamp).toLocaleDateString()} • {constraintCount} constraints
                        </span>
                      </div>
                    </NeoAccordionTrigger>
                    <NeoAccordionContent isOpen={isOpen}>
                      {sess.selections && (
                        <div style={{ 
                          display: 'flex', 
                          flexDirection: 'column', 
                          gap: 'var(--space-sm)' 
                        }}>
                          {Object.entries(sess.selections).map(([key, value]) => {
                            const step = allSteps.find(s => s.id === key);
                            if (!step || !value) return null;
                            return (
                              <div key={key} style={{
                                borderLeft: '3px solid var(--color-primary)',
                                paddingLeft: 'var(--space-sm)'
                              }}>
                                <div style={{ 
                                  fontSize: '11px', 
                                  fontWeight: 'bold',
                                  textTransform: 'uppercase',
                                  marginBottom: '2px'
                                }}>
                                  {step.name}
                                </div>
                                <div style={{ fontSize: '13px', fontWeight: '600' }}>
                                  {value.label}
                                </div>
                              </div>
                            );
                          })}
                          <NeoButton 
                            onClick={() => viewSavedSession(sess._id)}
                            variant="primary"
                            size="sm"
                            style={{ marginTop: 'var(--space-sm)' }}
                          >
                            📖 View Full Blueprint
                          </NeoButton>
                        </div>
                      )}
                    </NeoAccordionContent>
                  </NeoAccordionItem>
                );
              })}
            </NeoAccordion>
          </NeoCardContent>
        </NeoCard>
      )}
    </NeoContainer>
  )
}
      // prettier-ignore-end

      const rootElement = document.getElementById('container');
      // Check for babel errors before attempting to render
      if (!window.babelTransformError) {
        ReactDOMClient.createRoot(rootElement).render(<App />);
      } else {
        // Create fallback error UI if babel failed
        rootElement.innerHTML = `
          <div style="padding: 20px; color: red; font-family: monospace; white-space: pre-wrap;">
            <h2>Syntax Error</h2>
            <p>${window.babelTransformError.message}</p>
          </div>
        `;
      }
    </script>
  </body>
</html>
